# WARNING: this file is auto-generated by 'build_sync_library.py'
# from the original file 'store.py'
# DO NOT CHANGE! Change the original file instead.
from collections.abc import Sequence
from typing import overload

from key_value.shared.utils.compound import compound_key
from key_value.shared.utils.managed_entry import ManagedEntry
from typing_extensions import override

from key_value.sync.code_gen.stores.base import BaseContextManagerStore, BaseStore

try:
    # Use redis-py asyncio client to communicate with a Valkey server (protocol compatible)
    from glide_shared.commands.core_options import ExpirySet, ExpiryType
    from glide_sync.config import GlideClientConfiguration, NodeAddress, ServerCredentials
    from glide_sync.glide_client import BaseClient, GlideClient
except ImportError as e:
    msg = "ValkeyStore requires py-key-value-aio[valkey]"
    raise ImportError(msg) from e

DEFAULT_PAGE_SIZE = 10000
PAGE_LIMIT = 10000


class ValkeyStore(BaseContextManagerStore, BaseStore):
    """Valkey-based key-value store (Redis protocol compatible)."""

    _connected_client: BaseClient | None
    _client_config: GlideClientConfiguration | None

    @overload
    def __init__(self, *, client: BaseClient, default_collection: str | None = None) -> None: ...

    @overload
    def __init__(
        self,
        *,
        host: str = "localhost",
        port: int = 6379,
        db: int = 0,
        username: str | None = None,
        password: str | None = None,
        default_collection: str | None = None,
    ) -> None: ...

    def __init__(
        self,
        *,
        client: BaseClient | None = None,
        default_collection: str | None = None,
        host: str = "localhost",
        port: int = 6379,
        db: int = 0,
        username: str | None = None,
        password: str | None = None,
    ) -> None:
        if client is not None:
            self._connected_client = client
        else:
            # redis client accepts URL
            addresses: list[NodeAddress] = [NodeAddress(host=host, port=port)]
            credentials: ServerCredentials | None = ServerCredentials(password=password, username=username) if password else None
            self._client_config = GlideClientConfiguration(addresses=addresses, database_id=db, credentials=credentials)
            self._connected_client = None

        self._stable_api = True

        super().__init__(default_collection=default_collection)

    @override
    def _setup(self) -> None:
        if self._connected_client is None:
            if self._client_config is None:
                # This should never happen, makes the type checker happy though
                msg = "Client configuration is not set"
                raise ValueError(msg)

            self._connected_client = GlideClient.create(config=self._client_config)

    @property
    def _client(self) -> BaseClient:
        if self._connected_client is None:
            # This should never happen, makes the type checker happy though
            msg = "Client is not connected"
            raise ValueError(msg)
        return self._connected_client

    @override
    def _get_managed_entry(self, *, key: str, collection: str) -> ManagedEntry | None:
        combo_key: str = compound_key(collection=collection, key=key)

        response: bytes | None = self._client.get(key=combo_key)
        if not isinstance(response, bytes):
            return None
        decoded_response: str = response.decode("utf-8")
        return ManagedEntry.from_json(json_str=decoded_response)

    @override
    def _get_managed_entries(self, *, collection: str, keys: Sequence[str]) -> list[ManagedEntry | None]:
        if not keys:
            return []

        combo_keys: list[str] = [compound_key(collection=collection, key=key) for key in keys]

        responses: list[bytes | None] = self._client.mget(keys=combo_keys)  # pyright: ignore[reportUnknownMemberType, reportArgumentType]

        entries: list[ManagedEntry | None] = []
        for response in responses:
            if isinstance(response, bytes):
                decoded_response: str = response.decode("utf-8")
                entries.append(ManagedEntry.from_json(json_str=decoded_response))
            else:
                entries.append(None)

        return entries

    @override
    def _put_managed_entry(self, *, key: str, collection: str, managed_entry: ManagedEntry) -> None:
        combo_key: str = compound_key(collection=collection, key=key)

        json_value: str = managed_entry.to_json()

        expiry: ExpirySet | None = ExpirySet(expiry_type=ExpiryType.SEC, value=int(managed_entry.ttl)) if managed_entry.ttl else None

        _ = self._client.set(key=combo_key, value=json_value, expiry=expiry)

    # Note: Valkey doesn't have a true bulk write API with per-key TTL support
    # The base implementation's loop is equivalent to what we would do here
    # so we use the default BaseStore implementation

    @override
    def _delete_managed_entry(self, *, key: str, collection: str) -> bool:
        combo_key: str = compound_key(collection=collection, key=key)
        return self._client.delete(keys=[combo_key]) != 0

    @override
    def _delete_managed_entries(self, *, keys: Sequence[str], collection: str) -> int:
        if not keys:
            return 0

        combo_keys: list[str] = [compound_key(collection=collection, key=key) for key in keys]
        deleted_count: int = self._client.delete(keys=combo_keys)  # pyright: ignore[reportArgumentType]

        return deleted_count

    @override
    def _close(self) -> None:
        if self._connected_client is None:
            return
        self._client.close()
