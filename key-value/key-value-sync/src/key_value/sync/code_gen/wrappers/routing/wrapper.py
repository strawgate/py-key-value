# WARNING: this file is auto-generated by 'build_sync_library.py'
# from the original file 'wrapper.py'
# DO NOT CHANGE! Change the original file instead.
from collections.abc import Callable, Mapping, Sequence
from typing import Any, SupportsFloat

from typing_extensions import override

from key_value.sync.code_gen.protocols.key_value import KeyValue
from key_value.sync.code_gen.wrappers.base import BaseWrapper

RoutingFunction = Callable[[str | None], KeyValue | None]


class RoutingWrapper(BaseWrapper):
    """Routes operations to different stores based on a routing function.

    The routing function receives the collection name and key and returns the appropriate store.
    This allows dynamic routing of requests to different backing stores based on
    collection name or other custom logic.

    Example:
        def route_by_collection(collection: str | None) -> KeyValue | None:
            if collection == "sessions":
                return redis_store
            elif collection == "users":
                return dynamo_store
            return None

        router = RoutingWrapper(
            routing_function=route_by_collection,
            default_store=memory_store
        )
    """

    def __init__(self, routing_function: RoutingFunction, default_store: KeyValue) -> None:
        """Initialize the routing wrapper.

        Args:
            routing_function: Function that takes a collection name and returns the store to use.
                             Should return None if no specific store is found.
            default_store: Fallback store if routing_function returns None.
        """
        self.routing_function = routing_function
        self.default_store = default_store

    def _get_store(self, collection: str | None) -> KeyValue:
        """Get the appropriate store for the given collection.

        Args:
            collection: The collection name to route.

        Returns:
            The KeyValue store to use for this collection.

        Raises:
            ValueError: If no store is found for the collection and no default store is configured.
        """
        store: KeyValue | None = self.routing_function(collection)
        if store is None:
            return self.default_store
        return store

    @override
    def get(self, key: str, *, collection: str | None = None) -> dict[str, Any] | None:
        store: KeyValue = self._get_store(collection)
        return store.get(key=key, collection=collection)

    @override
    def get_many(self, keys: Sequence[str], *, collection: str | None = None) -> list[dict[str, Any] | None]:
        store: KeyValue = self._get_store(collection)
        return store.get_many(keys=keys, collection=collection)

    @override
    def ttl(self, key: str, *, collection: str | None = None) -> tuple[dict[str, Any] | None, float | None]:
        store: KeyValue = self._get_store(collection)
        return store.ttl(key=key, collection=collection)

    @override
    def ttl_many(self, keys: Sequence[str], *, collection: str | None = None) -> list[tuple[dict[str, Any] | None, float | None]]:
        store: KeyValue = self._get_store(collection)
        return store.ttl_many(keys=keys, collection=collection)

    @override
    def put(self, key: str, value: Mapping[str, Any], *, collection: str | None = None, ttl: SupportsFloat | None = None) -> None:
        store: KeyValue = self._get_store(collection)
        return store.put(key=key, value=value, collection=collection, ttl=ttl)

    @override
    def put_many(
        self, keys: Sequence[str], values: Sequence[Mapping[str, Any]], *, collection: str | None = None, ttl: SupportsFloat | None = None
    ) -> None:
        store: KeyValue = self._get_store(collection)
        return store.put_many(keys=keys, values=values, collection=collection, ttl=ttl)

    @override
    def delete(self, key: str, *, collection: str | None = None) -> bool:
        store: KeyValue = self._get_store(collection)
        return store.delete(key=key, collection=collection)

    @override
    def delete_many(self, keys: Sequence[str], *, collection: str | None = None) -> int:
        store: KeyValue = self._get_store(collection)
        return store.delete_many(keys=keys, collection=collection)
