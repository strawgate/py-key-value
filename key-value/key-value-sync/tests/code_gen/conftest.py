# WARNING: this file is auto-generated by 'build_sync_library.py'
# from the original file 'conftest.py'
# DO NOT CHANGE! Change the original file instead.
import asyncio
import logging
import os
import platform
import subprocess
from collections.abc import Callable, Iterator
from contextlib import contextmanager
from pathlib import Path

import pytest
from docker import DockerClient
from docker.models.containers import Container
from key_value.shared.code_gen.sleep import sleep

logger = logging.getLogger(__name__)

logging.basicConfig(level=logging.INFO)


@contextmanager
def try_import() -> Iterator[Callable[[], bool]]:
    import_success = False

    def check_import() -> bool:
        return import_success

    try:
        yield check_import
    except ImportError:
        pass
    else:
        import_success = True


def get_docker_client() -> DockerClient:
    return DockerClient.from_env()


@pytest.fixture
def docker_client() -> DockerClient:
    return get_docker_client()


def docker_logs(name: str, print_logs: bool = False, raise_on_error: bool = False, log_level: int = logging.INFO) -> list[str]:
    client = get_docker_client()
    try:
        logs: list[str] = client.containers.get(name).logs().decode("utf-8").splitlines()
    except Exception:
        logger.info(f"Container {name} failed to get logs")
        if raise_on_error:
            raise
        return []

    if print_logs:
        logger.info(f"Container {name} logs:")
        for log in logs:
            logger.log(log_level, log)

    return logs


def docker_get(name: str, raise_on_not_found: bool = False) -> Container | None:
    from docker.errors import NotFound

    client = get_docker_client()
    try:
        return client.containers.get(name)
    except NotFound:
        logger.info(f"Container {name} failed to get")
        if raise_on_not_found:
            raise
        return None


def docker_pull(image: str, raise_on_error: bool = False) -> bool:
    logger.info(f"Pulling image {image}")
    client = get_docker_client()
    try:
        client.images.pull(image)
    except Exception:
        logger.exception(f"Image {image} failed to pull")
        if raise_on_error:
            raise
        return False
    return True


def docker_stop(name: str, raise_on_error: bool = False) -> bool:
    logger.info(f"Stopping container {name}")

    if not (container := docker_get(name=name, raise_on_not_found=False)):
        return False

    try:
        container.stop()
    except Exception:
        logger.info(f"Container {name} failed to stop")
        if raise_on_error:
            raise
        return False

    logger.info(f"Container {name} stopped")
    return True


def docker_wait_container_gone(name: str, max_tries: int = 10, wait_time: float = 1.0) -> bool:
    logger.info(f"Waiting for container {name} to be gone")
    count = 0
    while count < max_tries:
        if not docker_get(name=name, raise_on_not_found=False):
            return True
        sleep(wait_time)
        count += 1
    return False


def docker_rm(name: str, raise_on_error: bool = False) -> bool:
    logger.info(f"Removing container {name}")

    if not (container := docker_get(name=name, raise_on_not_found=False)):
        return False

    try:
        container.remove()
    except Exception:
        logger.info(f"Container {name} failed to remove")
        if raise_on_error:
            raise
        return False
    logger.info(f"Container {name} removed")
    return True


def docker_run(name: str, image: str, ports: dict[str, int], environment: dict[str, str], raise_on_error: bool = False) -> bool:
    logger.info(f"Running container {name} with image {image} and ports {ports}")
    client = get_docker_client()
    try:
        client.containers.run(name=name, image=image, ports=ports, environment=environment, detach=True)
    except Exception:
        logger.exception(f"Container {name} failed to run")
        if raise_on_error:
            raise
        return False
    logger.info(f"Container {name} running")
    return True


@contextmanager
def docker_container(
    name: str, image: str, ports: dict[str, int], environment: dict[str, str] | None = None, raise_on_error: bool = True
) -> Iterator[None]:
    logger.info(f"Creating container {name} with image {image} and ports {ports}")
    try:
        docker_pull(image=image, raise_on_error=True)
        docker_stop(name=name, raise_on_error=False)
        docker_rm(name=name, raise_on_error=False)
        docker_wait_container_gone(name=name, max_tries=10, wait_time=1.0)
        docker_run(name=name, image=image, ports=ports, environment=environment or {}, raise_on_error=True)
        logger.info(f"Container {name} created")
        yield
        docker_logs(name, print_logs=True, raise_on_error=False)
    except Exception:
        logger.info(f"Creating container {name} failed")
        docker_logs(name, print_logs=True, raise_on_error=False, log_level=logging.ERROR)
        if raise_on_error:
            raise
        return
    finally:
        docker_stop(name, raise_on_error=False)
        docker_rm(name, raise_on_error=False)
        docker_wait_container_gone(name=name, max_tries=10, wait_time=1.0)

    logger.info(f"Container {name} stopped and removed")
    return


def async_running_in_event_loop() -> bool:
    try:
        asyncio.get_event_loop_policy().get_event_loop()
    except RuntimeError:
        return False
    return True


def running_in_event_loop() -> bool:
    return False


def detect_docker() -> bool:
    try:
        result = subprocess.run(["docker", "ps"], check=False, capture_output=True, text=True)  # noqa: S607
    except Exception:
        return False
    else:
        return result.returncode == 0


def detect_on_ci() -> bool:
    return os.getenv("CI", "false") == "true"


def detect_on_windows() -> bool:
    return platform.system() == "Windows"


def detect_on_macos() -> bool:
    return platform.system() == "Darwin"


def detect_on_linux() -> bool:
    return platform.system() == "Linux"


def should_run_docker_tests() -> bool:
    if detect_on_ci():
        return all([detect_docker(), not detect_on_windows(), not detect_on_macos()])
    return detect_docker()


def should_skip_docker_tests() -> bool:
    return not should_run_docker_tests()


def detect_docker_compose() -> bool:
    """Check if docker compose (v2) is available."""
    try:
        result = subprocess.run(["docker", "compose", "version"], check=False, capture_output=True, text=True)  # noqa: S607
    except Exception:
        return False
    else:
        return result.returncode == 0


def should_skip_docker_compose_tests() -> bool:
    """Check if docker compose tests should be skipped."""
    return not (should_run_docker_tests() and detect_docker_compose())


@contextmanager
def docker_compose_cluster(
    compose_file: Path, project_name: str, environment: dict[str, str] | None = None, timeout: int = 120
) -> Iterator[None]:
    """Context manager that starts a docker-compose cluster and tears it down after.

    Args:
        compose_file: Path to the docker-compose.yml file
        project_name: Unique project name for docker compose
        environment: Additional environment variables to pass to docker-compose
        timeout: Timeout in seconds to wait for the cluster to be ready
    """
    logger.info(f"Starting docker compose cluster from {compose_file} with project {project_name}")

    env = {**os.environ, **(environment or {})}

    try:
        # Pull images first
        logger.info("Pulling docker compose images...")
        pull_result = subprocess.run(  # noqa: S603
            ["docker", "compose", "-f", str(compose_file), "-p", project_name, "pull"],  # noqa: S607
            check=False,
            capture_output=True,
            text=True,
            env=env,
        )
        if pull_result.returncode != 0:
            logger.warning(f"Failed to pull images: {pull_result.stderr}")

        # Start the cluster
        logger.info("Starting docker compose cluster...")
        up_result = subprocess.run(  # noqa: S603
            ["docker", "compose", "-f", str(compose_file), "-p", project_name, "up", "-d", "--wait", f"--wait-timeout={timeout}"],  # noqa: S607
            check=False,
            capture_output=True,
            text=True,
            env=env,
        )
        if up_result.returncode != 0:
            logger.error(f"Failed to start cluster: {up_result.stderr}")
            # Try to get logs for debugging
            subprocess.run(  # noqa: S603
                ["docker", "compose", "-f", str(compose_file), "-p", project_name, "logs"],  # noqa: S607
                check=False,
                env=env,
            )
            msg = f"Failed to start docker compose cluster: {up_result.stderr}"
            raise RuntimeError(msg)

        logger.info("Docker compose cluster started successfully")
        yield
    finally:
        # Print logs for debugging
        logger.info("Printing docker compose logs...")
        subprocess.run(  # noqa: S603
            ["docker", "compose", "-f", str(compose_file), "-p", project_name, "logs"],  # noqa: S607
            check=False,
            env=env,
        )
        # Tear down the cluster
        logger.info("Stopping docker compose cluster...")
        subprocess.run(  # noqa: S603
            ["docker", "compose", "-f", str(compose_file), "-p", project_name, "down", "-v", "--remove-orphans"],  # noqa: S607
            check=False,
            capture_output=True,
            text=True,
            env=env,
        )
        logger.info("Docker compose cluster stopped and removed")
