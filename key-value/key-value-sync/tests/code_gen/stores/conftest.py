# WARNING: this file is auto-generated by 'build_sync_library.py'
# from the original file 'conftest.py'
# DO NOT CHANGE! Change the original file instead.
import asyncio
import hashlib
import os
import subprocess
from abc import ABC, abstractmethod
from collections.abc import Callable, Generator
from datetime import datetime, timedelta, timezone
from typing import Any

import pytest
from dirty_equals import IsFloat
from pydantic import AnyHttpUrl

from key_value.sync.code_gen.errors import InvalidTTLError, SerializationError
from key_value.sync.code_gen.stores.base import BaseContextManagerStore, BaseStore
from key_value.sync.code_gen.stores.memory.store import MemoryStore
from key_value.sync.code_gen.utils.acompat import sleep
from tests.code_gen.cases import DICTIONARY_TO_JSON_TEST_CASES_NAMES, OBJECT_TEST_CASES
from tests.code_gen.conftest import running_in_event_loop


@pytest.fixture
def memory_store() -> MemoryStore:
    return MemoryStore(max_entries_per_collection=500)


def now() -> datetime:
    return datetime.now(tz=timezone.utc)


def now_plus(seconds: int) -> datetime:
    return now() + timedelta(seconds=seconds)


def is_around(value: float, delta: float = 1) -> bool:
    return value - delta < value < value + delta


def detect_docker() -> bool:
    try:
        result = subprocess.run(["docker", "ps"], check=False, capture_output=True, text=True)  # noqa: S607
    except Exception:
        return False
    else:
        return result.returncode == 0


def detect_on_ci() -> bool:
    return os.getenv("CI", "false") == "true"


def detect_on_windows() -> bool:
    return os.name == "nt"


def detect_on_macos() -> bool:
    return os.name == "darwin"


def should_run_docker_tests() -> bool:
    if detect_on_ci():
        return all([detect_docker(), not detect_on_windows(), not detect_on_macos()])
    return detect_docker()


def should_skip_docker_tests() -> bool:
    return not should_run_docker_tests()


def wait_for_store(wait_fn: Callable[[], bool], max_time: int = 10) -> bool:
    for _ in range(max_time):
        if wait_fn():
            return True
        sleep(seconds=1)
    return False


class BaseStoreTests(ABC):
    def eventually_consistent(self) -> None:  # noqa: B027
        "Subclasses can override this to wait for eventually consistent operations."

    @pytest.fixture
    @abstractmethod
    def store(self) -> BaseStore | Generator[BaseStore, None, None]: ...

    # The first test requires a docker pull, so we only time the actual test

    @pytest.mark.timeout(5, func_only=True)
    def test_empty_get(self, store: BaseStore):
        """Tests that the get method returns None from an empty store."""
        assert store.get(collection="test", key="test") is None

    def test_empty_put(self, store: BaseStore):
        """Tests that the put method does not raise an exception when called on a new store."""
        store.put(collection="test", key="test", value={"test": "test"})

    def test_empty_ttl(self, store: BaseStore):
        """Tests that the ttl method returns None from an empty store."""
        assert store.ttl(collection="test", key="test") == (None, None)

    def test_put_serialization_errors(self, store: BaseStore):
        """Tests that the put method does not raise an exception when called on a new store."""
        with pytest.raises(SerializationError):
            store.put(collection="test", key="test", value={"test": AnyHttpUrl("https://test.com")})

    def test_get_put_get(self, store: BaseStore):
        assert store.get(collection="test", key="test") is None
        store.put(collection="test", key="test", value={"test": "test"})
        assert store.get(collection="test", key="test") == {"test": "test"}

    @pytest.mark.parametrize(argnames="value", argvalues=OBJECT_TEST_CASES, ids=DICTIONARY_TO_JSON_TEST_CASES_NAMES)
    def test_get_complex_put_get(self, store: BaseStore, value: dict[str, Any]):
        store.put(collection="test", key="test", value=value)
        assert store.get(collection="test", key="test") == value

    def test_put_many_get(self, store: BaseStore):
        store.put_many(collection="test", keys=["test", "test_2"], values=[{"test": "test"}, {"test": "test_2"}])
        assert store.get(collection="test", key="test") == {"test": "test"}
        assert store.get(collection="test", key="test_2") == {"test": "test_2"}

    def test_put_many_get_many(self, store: BaseStore):
        store.put_many(collection="test", keys=["test", "test_2"], values=[{"test": "test"}, {"test": "test_2"}])
        assert store.get_many(collection="test", keys=["test", "test_2"]) == [{"test": "test"}, {"test": "test_2"}]

    def test_put_put_get_many(self, store: BaseStore):
        store.put(collection="test", key="test", value={"test": "test"})
        store.put(collection="test", key="test_2", value={"test": "test_2"})
        assert store.get_many(collection="test", keys=["test", "test_2"]) == [{"test": "test"}, {"test": "test_2"}]

    def test_put_put_get_many_missing_one(self, store: BaseStore):
        store.put(collection="test", key="test", value={"test": "test"})
        store.put(collection="test", key="test_2", value={"test": "test_2"})
        assert store.get_many(collection="test", keys=["test", "test_2", "test_3"]) == [{"test": "test"}, {"test": "test_2"}, None]

    def test_put_get_delete_get(self, store: BaseStore):
        store.put(collection="test", key="test", value={"test": "test"})
        assert store.get(collection="test", key="test") == {"test": "test"}
        assert store.delete(collection="test", key="test")
        assert store.get(collection="test", key="test") is None

    def test_put_many_get_get_delete_many_get_many(self, store: BaseStore):
        store.put_many(collection="test", keys=["test", "test_2"], values=[{"test": "test"}, {"test": "test_2"}])
        assert store.get_many(collection="test", keys=["test", "test_2"]) == [{"test": "test"}, {"test": "test_2"}]
        assert store.delete_many(collection="test", keys=["test", "test_2"]) == 2
        assert store.get_many(collection="test", keys=["test", "test_2"]) == [None, None]

    def test_put_many_get_many_delete_many_get_many(self, store: BaseStore):
        store.put_many(collection="test", keys=["test", "test_2"], values=[{"test": "test"}, {"test": "test_2"}])
        assert store.get_many(collection="test", keys=["test", "test_2"]) == [{"test": "test"}, {"test": "test_2"}]
        assert store.delete_many(collection="test", keys=["test", "test_2"]) == 2
        assert store.get_many(collection="test", keys=["test", "test_2"]) == [None, None]

    def test_get_put_get_delete_get(self, store: BaseStore):
        """Tests that the get, put, delete, and get methods work together to store and retrieve a value from an empty store."""

        assert store.get(collection="test", key="test") is None

        store.put(collection="test", key="test", value={"test": "test"})

        assert store.get(collection="test", key="test") == {"test": "test"}

        assert store.delete(collection="test", key="test")

        assert store.get(collection="test", key="test") is None

    def test_get_put_get_put_delete_get(self, store: BaseStore):
        """Tests that the get, put, get, put, delete, and get methods work together to store and retrieve a value from an empty store."""
        store.put(collection="test", key="test", value={"test": "test"})
        assert store.get(collection="test", key="test") == {"test": "test"}

        store.put(collection="test", key="test", value={"test": "test_2"})

        assert store.get(collection="test", key="test") == {"test": "test_2"}
        assert store.delete(collection="test", key="test")
        assert store.get(collection="test", key="test") is None

    def test_put_many_delete_delete_get_many(self, store: BaseStore):
        store.put_many(collection="test", keys=["test", "test_2"], values=[{"test": "test"}, {"test": "test_2"}])
        assert store.get_many(collection="test", keys=["test", "test_2"]) == [{"test": "test"}, {"test": "test_2"}]
        assert store.delete(collection="test", key="test")
        assert store.delete(collection="test", key="test_2")
        assert store.get_many(collection="test", keys=["test", "test_2"]) == [None, None]

    def test_put_ttl_get_ttl(self, store: BaseStore):
        """Tests that the put and get ttl methods work together to store and retrieve a ttl from an empty store."""
        store.put(collection="test", key="test", value={"test": "test"}, ttl=100)
        (value, ttl) = store.ttl(collection="test", key="test")

        assert value == {"test": "test"}
        assert ttl is not None
        assert ttl == IsFloat(approx=100)

    def test_negative_ttl(self, store: BaseStore):
        """Tests that a negative ttl will return None when getting the key."""
        with pytest.raises(InvalidTTLError):
            store.put(collection="test", key="test", value={"test": "test"}, ttl=-100)

    @pytest.mark.timeout(10)
    def test_put_expired_get_none(self, store: BaseStore):
        """Tests that a put call with a negative ttl will return None when getting the key."""
        store.put(collection="test_collection", key="test_key", value={"test": "test"}, ttl=1)
        sleep(seconds=3)
        assert store.get(collection="test_collection", key="test_key") is None

    def test_long_collection_name(self, store: BaseStore):
        """Tests that a long collection name will not raise an error."""
        store.put(collection="test_collection" * 100, key="test_key", value={"test": "test"})
        assert store.get(collection="test_collection" * 100, key="test_key") == {"test": "test"}

    def test_special_characters_in_collection_name(self, store: BaseStore):
        """Tests that a special characters in the collection name will not raise an error."""
        store.put(collection="test_collection!@#$%^&*()", key="test_key", value={"test": "test"})
        assert store.get(collection="test_collection!@#$%^&*()", key="test_key") == {"test": "test"}

    def test_long_key_name(self, store: BaseStore):
        """Tests that a long key name will not raise an error."""
        store.put(collection="test_collection", key="test_key" * 100, value={"test": "test"})
        assert store.get(collection="test_collection", key="test_key" * 100) == {"test": "test"}

    def test_special_characters_in_key_name(self, store: BaseStore):
        """Tests that a special characters in the key name will not raise an error."""
        store.put(collection="test_collection", key="test_key!@#$%^&*()", value={"test": "test"})
        assert store.get(collection="test_collection", key="test_key!@#$%^&*()") == {"test": "test"}

    @pytest.mark.timeout(20)
    def test_not_unbounded(self, store: BaseStore):
        """Tests that the store is not unbounded."""

        for i in range(1000):
            value = hashlib.sha256(f"test_{i}".encode()).hexdigest()
            store.put(collection="test_collection", key=f"test_key_{i}", value={"test": value})

        assert store.get(collection="test_collection", key="test_key_0") is None
        assert store.get(collection="test_collection", key="test_key_999") is not None

    @pytest.mark.skipif(condition=not running_in_event_loop(), reason="Cannot run concurrent operations in event loop")
    def test_concurrent_operations(self, store: BaseStore):
        """Tests that the store can handle concurrent operations."""

        def worker(store: BaseStore, worker_id: int):
            for i in range(10):
                assert store.get(collection="test_collection", key=f"test_{worker_id}_{i}") is None

                store.put(collection="test_collection", key=f"test_{worker_id}_{i}", value={"test": f"test_{i}"})
                assert store.get(collection="test_collection", key=f"test_{worker_id}_{i}") == {"test": f"test_{i}"}

                store.put(collection="test_collection", key=f"test_{worker_id}_{i}", value={"test": f"test_{i}_2"})
                assert store.get(collection="test_collection", key=f"test_{worker_id}_{i}") == {"test": f"test_{i}_2"}

                assert store.delete(collection="test_collection", key=f"test_{worker_id}_{i}")
                assert store.get(collection="test_collection", key=f"test_{worker_id}_{i}") is None

        _ = asyncio.gather(*[worker(store, worker_id) for worker_id in range(5)])

    @pytest.mark.timeout(15)
    def test_minimum_put_many_get_many_performance(self, store: BaseStore):
        """Tests that the store meets minimum performance requirements."""
        keys = [f"test_{i}" for i in range(10)]
        values = [{"test": f"test_{i}"} for i in range(10)]
        store.put_many(collection="test_collection", keys=keys, values=values)
        assert store.get_many(collection="test_collection", keys=keys) == values

    @pytest.mark.timeout(15)
    def test_minimum_put_many_delete_many_performance(self, store: BaseStore):
        """Tests that the store meets minimum performance requirements."""
        keys = [f"test_{i}" for i in range(10)]
        values = [{"test": f"test_{i}"} for i in range(10)]
        store.put_many(collection="test_collection", keys=keys, values=values)
        assert store.delete_many(collection="test_collection", keys=keys) == 10


class ContextManagerStoreTestMixin:
    @pytest.fixture(params=[True, False], ids=["with_ctx_manager", "no_ctx_manager"], autouse=True)
    def enter_exit_store(
        self, request: pytest.FixtureRequest, store: BaseContextManagerStore
    ) -> Generator[BaseContextManagerStore, None, None]:
        context_manager = request.param  # pyright: ignore[reportAny]

        if context_manager:
            with store:
                yield store
        else:
            yield store
            store.close()
