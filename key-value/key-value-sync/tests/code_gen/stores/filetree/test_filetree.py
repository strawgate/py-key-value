# WARNING: this file is auto-generated by 'build_sync_library.py'
# from the original file 'test_filetree.py'
# DO NOT CHANGE! Change the original file instead.
"""Tests for FileTreeStore."""

import json
import tempfile
from collections.abc import Generator

import pytest
from typing_extensions import override

from key_value.sync.code_gen.stores.base import BaseStore
from key_value.sync.code_gen.stores.filetree import FileTreeStore
from tests.code_gen.stores.base import BaseStoreTests


class TestFileTreeStore(BaseStoreTests):
    """Test suite for FileTreeStore."""

    @pytest.fixture
    def store(self) -> Generator[FileTreeStore, None, None]:
        """Create a FileTreeStore instance with a temporary directory."""
        with tempfile.TemporaryDirectory() as temp_dir:
            yield FileTreeStore(directory=temp_dir)

    @override
    def test_not_unbounded(self, store: BaseStore):
        """FileTreeStore is unbounded, so skip this test."""
        pytest.skip("FileTreeStore is unbounded and does not evict old entries")

    @override
    def test_long_collection_name(self, store: BaseStore):
        """FileTreeStore has filesystem path length limits."""
        pytest.skip("FileTreeStore is limited by filesystem path length constraints")

    @override
    def test_long_key_name(self, store: BaseStore):
        """FileTreeStore has filesystem filename length limits."""
        pytest.skip("FileTreeStore is limited by filesystem filename length constraints")

    def test_visual_inspection_collection_as_directory(self, store: FileTreeStore):
        """Test that collections create subdirectories."""
        store.put(collection="test_collection", key="test_key", value={"test": "test"})

        collection_path = store._directory / "test_collection"  # pyright: ignore[reportPrivateUsage]
        assert collection_path.exists()
        assert collection_path.is_dir()

    def test_visual_inspection_key_as_filename(self, store: FileTreeStore):
        """Test that keys map to filenames correctly."""
        store.put(collection="test_collection", key="test_key", value={"test": "test"})

        key_path = store._directory / "test_collection" / "test_key.json"  # pyright: ignore[reportPrivateUsage]
        assert key_path.exists()
        assert key_path.is_file()

    def test_visual_inspection_json_file_content(self, store: FileTreeStore):
        """Test that file contents are valid JSON."""
        store.put(collection="test_collection", key="test_key", value={"test": "test_value", "number": 42})

        key_path = store._directory / "test_collection" / "test_key.json"  # pyright: ignore[reportPrivateUsage]
        content = key_path.read_text(encoding="utf-8")

        # Verify it's valid JSON
        data = json.loads(content)
        assert "value" in data
        assert data["value"]["test"] == "test_value"
        assert data["value"]["number"] == 42

    def test_expired_file_remains_on_disk(self, store: FileTreeStore):
        """Test that expired entries remain on disk but are filtered on read."""
        store.put(collection="test_collection", key="test_key", value={"test": "test"}, ttl=0.1)

        key_path = store._directory / "test_collection" / "test_key.json"  # pyright: ignore[reportPrivateUsage]
        assert key_path.exists()

        # Wait for expiration
        from key_value.shared.code_gen.sleep import sleep

        sleep(seconds=0.2)

        # Entry should still be on disk
        assert key_path.exists()

        # But get should return None (filtered out)
        assert store.get(collection="test_collection", key="test_key") is None

    def test_collection_enumeration(self, store: FileTreeStore):
        """Test that we can enumerate collections."""
        store.put(collection="collection_1", key="key_1", value={"test": "1"})
        store.put(collection="collection_2", key="key_2", value={"test": "2"})

        collections = store.collections()
        assert "collection_1" in collections
        assert "collection_2" in collections

    def test_key_enumeration(self, store: FileTreeStore):
        """Test that we can enumerate keys in a collection."""
        store.put(collection="test_collection", key="key_1", value={"test": "1"})
        store.put(collection="test_collection", key="key_2", value={"test": "2"})
        store.put(collection="test_collection", key="key_3", value={"test": "3"})

        keys = store.keys(collection="test_collection")
        assert "key_1" in keys
        assert "key_2" in keys
        assert "key_3" in keys

    def test_delete_collection(self, store: FileTreeStore):
        """Test that we can delete an entire collection."""
        store.put(collection="test_collection", key="key_1", value={"test": "1"})
        store.put(collection="test_collection", key="key_2", value={"test": "2"})

        collection_path = store._directory / "test_collection"  # pyright: ignore[reportPrivateUsage]
        assert collection_path.exists()

        result = store.destroy_collection(collection="test_collection")
        assert result is True
        assert not collection_path.exists()

    def test_delete_store(self, store: FileTreeStore):
        """Test that we can delete the entire store."""
        store.put(collection="collection_1", key="key_1", value={"test": "1"})
        store.put(collection="collection_2", key="key_2", value={"test": "2"})

        result = store.destroy()
        assert result is True

        # All collections should be gone
        assert len(list(store._directory.iterdir())) == 0  # pyright: ignore[reportPrivateUsage]

    def test_handles_missing_collection_gracefully(self, store: FileTreeStore):
        """Test that operations on missing collections are handled gracefully."""
        keys = store.keys(collection="nonexistent_collection")
        assert keys == []

    def test_handles_corrupted_file(self, store: FileTreeStore):
        """Test that corrupted JSON files are handled gracefully."""
        # Create a collection directory
        collection_path = store._directory / "test_collection"  # pyright: ignore[reportPrivateUsage]
        collection_path.mkdir(parents=True, exist_ok=True)

        # Write invalid JSON
        key_path = collection_path / "corrupted_key.json"
        key_path.write_text("this is not valid json", encoding="utf-8")

        # Should return None instead of crashing
        result = store.get(collection="test_collection", key="corrupted_key")
        assert result is None

    def test_multiple_collections(self, store: FileTreeStore):
        """Test that multiple collections work independently."""
        store.put(collection="collection_1", key="shared_key", value={"collection": "1"})
        store.put(collection="collection_2", key="shared_key", value={"collection": "2"})

        result_1 = store.get(collection="collection_1", key="shared_key")
        result_2 = store.get(collection="collection_2", key="shared_key")

        assert result_1 == {"collection": "1"}
        assert result_2 == {"collection": "2"}

    def test_directory_structure(self, store: FileTreeStore):
        """Test the overall directory structure is correct."""
        store.put(collection="col1", key="key1", value={"data": "1"})
        store.put(collection="col1", key="key2", value={"data": "2"})
        store.put(collection="col2", key="key3", value={"data": "3"})

        base_dir = store._directory  # pyright: ignore[reportPrivateUsage]

        # Check collections exist as directories
        assert (base_dir / "col1").is_dir()
        assert (base_dir / "col2").is_dir()

        # Check keys exist as JSON files
        assert (base_dir / "col1" / "key1.json").is_file()
        assert (base_dir / "col1" / "key2.json").is_file()
        assert (base_dir / "col2" / "key3.json").is_file()
