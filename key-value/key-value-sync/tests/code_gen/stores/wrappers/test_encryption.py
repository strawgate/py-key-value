# WARNING: this file is auto-generated by 'build_sync_library.py'
# from the original file 'test_encryption.py'
# DO NOT CHANGE! Change the original file instead.
from typing import Any

import pytest
from cryptography.fernet import Fernet
from key_value.shared.errors.wrappers.encryption import DecryptionError
from typing_extensions import override

from key_value.sync.code_gen.stores.memory.store import MemoryStore
from key_value.sync.code_gen.wrappers.encryption import EncryptionWrapper
from tests.code_gen.stores.base import BaseStoreTests


class TestEncryptionWrapper(BaseStoreTests):
    @override
    @pytest.fixture
    def store(self, memory_store: MemoryStore) -> EncryptionWrapper:
        # Generate a key for testing
        encryption_key = Fernet.generate_key()
        return EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key)

    def test_encryption_encrypts_value(self, memory_store: MemoryStore):
        """Test that values are actually encrypted in the underlying store."""
        encryption_key = Fernet.generate_key()
        encryption_store = EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key)

        original_value = {"test": "value", "number": 123}
        encryption_store.put(collection="test", key="test", value=original_value)

        # Check the underlying store - should be encrypted
        raw_value = memory_store.get(collection="test", key="test")
        assert raw_value is not None
        assert "__encrypted_data__" in raw_value
        assert "__encryption_version__" in raw_value
        assert isinstance(raw_value["__encrypted_data__"], str)

        # The encrypted data should not contain the original value
        assert "test" not in str(raw_value)
        assert "value" not in str(raw_value)

        # Retrieve through wrapper - should decrypt automatically
        result = encryption_store.get(collection="test", key="test")
        assert result == original_value

    def test_encryption_with_string_key(self, memory_store: MemoryStore):
        """Test that encryption works with a string key."""
        encryption_key = Fernet.generate_key().decode("utf-8")
        encryption_store = EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key)

        original_value = {"test": "value"}
        encryption_store.put(collection="test", key="test", value=original_value)

        result = encryption_store.get(collection="test", key="test")
        assert result == original_value

    def test_encryption_many_operations(self, memory_store: MemoryStore):
        """Test that encryption works with put_many and get_many."""
        encryption_key = Fernet.generate_key()
        encryption_store = EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key)

        keys = ["k1", "k2", "k3"]
        values = [{"data": "value1"}, {"data": "value2"}, {"data": "value3"}]

        encryption_store.put_many(collection="test", keys=keys, values=values)

        # Check underlying store - all should be encrypted
        for key in keys:
            raw_value = memory_store.get(collection="test", key=key)
            assert raw_value is not None
            assert "__encrypted_data__" in raw_value

        # Retrieve through wrapper
        results = encryption_store.get_many(collection="test", keys=keys)
        assert results == values

    def test_encryption_already_encrypted_not_reencrypted(self, memory_store: MemoryStore):
        """Test that already encrypted values are not re-encrypted."""
        encryption_key = Fernet.generate_key()
        encryption_store = EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key)

        # Manually create an encrypted value

        # Mock encrypted data
        encrypted_value = {"__encrypted_data__": "gAAAAABmxxx...", "__encryption_version__": 1}

        # Should not try to encrypt again
        result = encryption_store._encrypt_value(value=encrypted_value)  # pyright: ignore[reportPrivateUsage]
        assert result == encrypted_value

    def test_decryption_handles_unencrypted_data(self, memory_store: MemoryStore):
        """Test that unencrypted data is returned as-is."""
        encryption_key = Fernet.generate_key()
        encryption_store = EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key)

        # Store unencrypted data directly in underlying store
        unencrypted_value = {"test": "value"}
        memory_store.put(collection="test", key="test", value=unencrypted_value)

        # Should return as-is when retrieved through encryption wrapper
        result = encryption_store.get(collection="test", key="test")
        assert result == unencrypted_value

    def test_decryption_handles_corrupted_data(self, memory_store: MemoryStore):
        """Test that corrupted encrypted data is handled gracefully."""
        encryption_key = Fernet.generate_key()
        encryption_store = EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key)

        # Store corrupted encrypted data
        corrupted_value = {"__encrypted_data__": "invalid-encrypted-data!!!", "__encryption_version__": 1}
        memory_store.put(collection="test", key="test", value=corrupted_value)

        with pytest.raises(DecryptionError):
            encryption_store.get(collection="test", key="test")

    def test_decryption_ignores_corrupted_data(self, memory_store: MemoryStore):
        """Test that corrupted encrypted data is ignored."""
        encryption_key = Fernet.generate_key()
        encryption_store = EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key, raise_on_decryption_error=False)

        # Store corrupted encrypted data
        corrupted_value = {"__encrypted_data__": "invalid-encrypted-data!!!", "__encryption_version__": 1}
        memory_store.put(collection="test", key="test", value=corrupted_value)

        assert encryption_store.get(collection="test", key="test") is None

    def test_decryption_with_wrong_key_returns_original(self, memory_store: MemoryStore):
        """Test that decryption with the wrong key returns the original encrypted value."""
        encryption_key1 = Fernet.generate_key()
        encryption_key2 = Fernet.generate_key()

        encryption_store1 = EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key1)
        encryption_store2 = EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key2)

        original_value = {"test": "value"}
        encryption_store1.put(collection="test", key="test", value=original_value)

        with pytest.raises(DecryptionError):
            encryption_store2.get(collection="test", key="test")

    def test_encryption_with_ttl(self, memory_store: MemoryStore):
        """Test that encryption works with TTL."""
        encryption_key = Fernet.generate_key()
        encryption_store = EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key)

        original_value = {"test": "value"}
        encryption_store.put(collection="test", key="test", value=original_value, ttl=3600)

        # Check underlying store - should be encrypted
        raw_value = memory_store.get(collection="test", key="test")
        assert raw_value is not None
        assert "__encrypted_data__" in raw_value

        # Retrieve through wrapper with TTL
        (result, ttl) = encryption_store.ttl(collection="test", key="test")
        assert result == original_value
        assert ttl is not None
        assert ttl > 0

    def test_encryption_ttl_many(self, memory_store: MemoryStore):
        """Test that encryption works with ttl_many."""
        encryption_key = Fernet.generate_key()
        encryption_store = EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key)

        keys = ["k1", "k2"]
        values = [{"data": "value1"}, {"data": "value2"}]
        ttls = [3600, 7200]

        encryption_store.put_many(collection="test", keys=keys, values=values, ttl=ttls)

        # Retrieve through wrapper with TTL
        results = encryption_store.ttl_many(collection="test", keys=keys)
        assert len(results) == 2
        for (value, ttl), expected_value in zip(results, values, strict=True):
            assert value == expected_value
            assert ttl is not None
            assert ttl > 0

    def test_encryption_complex_data(self, memory_store: MemoryStore):
        """Test encryption with complex nested data structures."""
        encryption_key = Fernet.generate_key()
        encryption_store = EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key)

        complex_value = {
            "users": [{"name": "Alice", "age": 30, "active": True}, {"name": "Bob", "age": 25, "active": False}],
            "metadata": {"created_at": "2024-01-01T00:00:00Z", "version": 1},
            "tags": ["python", "encryption", "testing"],
        }

        encryption_store.put(collection="test", key="complex", value=complex_value)

        # Check underlying store - should be encrypted
        raw_value = memory_store.get(collection="test", key="complex")
        assert raw_value is not None
        assert "__encrypted_data__" in raw_value

        # Retrieve and verify
        result = encryption_store.get(collection="test", key="complex")
        assert result == complex_value

    def test_encryption_empty_dict(self, memory_store: MemoryStore):
        """Test encryption with an empty dictionary."""
        encryption_key = Fernet.generate_key()
        encryption_store = EncryptionWrapper(key_value=memory_store, encryption_key=encryption_key)

        empty_value: dict[str, Any] = {}
        encryption_store.put(collection="test", key="empty", value=empty_value)

        result = encryption_store.get(collection="test", key="empty")
        assert result == empty_value
