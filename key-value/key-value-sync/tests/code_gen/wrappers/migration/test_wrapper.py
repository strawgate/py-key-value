# WARNING: this file is auto-generated by 'build_sync_library.py'
# from the original file 'test_wrapper.py'
# DO NOT CHANGE! Change the original file instead.
"""Tests for MigrationWrapper."""

import pytest

from key_value.sync.code_gen.stores.memory import MemoryStore
from key_value.sync.code_gen.wrappers.migration import MigrationWrapper

pytestmark = pytest.mark.asyncio


class TestMigrationWrapper:
    """Tests for MigrationWrapper."""

    @pytest.fixture
    def current_store(self) -> MemoryStore:
        """Create a current store (new strategy)."""
        return MemoryStore()

    @pytest.fixture
    def legacy_store(self) -> MemoryStore:
        """Create a legacy store (old strategy)."""
        return MemoryStore()

    @pytest.fixture
    def wrapper(self, current_store: MemoryStore, legacy_store: MemoryStore) -> MigrationWrapper:
        """Create a migration wrapper."""
        return MigrationWrapper(current_store=current_store, legacy_store=legacy_store, migrate_on_read=False, cache_size=100)

    @pytest.fixture
    def migrating_wrapper(self, current_store: MemoryStore, legacy_store: MemoryStore) -> MigrationWrapper:
        """Create a migration wrapper with migrate_on_read=True."""
        return MigrationWrapper(
            current_store=current_store, legacy_store=legacy_store, migrate_on_read=True, delete_after_migration=False, cache_size=100
        )

    def test_get_from_current_store(self, wrapper: MigrationWrapper, current_store: MemoryStore) -> None:
        """Test getting a value from the current store."""
        current_store.put(key="test_key", value={"data": "current"}, collection="default")

        result = wrapper.get(key="test_key", collection="default")
        assert result is not None
        assert result["data"] == "current"

    def test_get_from_legacy_store(self, wrapper: MigrationWrapper, legacy_store: MemoryStore, current_store: MemoryStore) -> None:
        """Test getting a value from the legacy store when not in current."""
        legacy_store.put(key="test_key", value={"data": "legacy"}, collection="default")

        result = wrapper.get(key="test_key", collection="default")
        assert result is not None
        assert result["data"] == "legacy"

        # Should NOT have been migrated (migrate_on_read=False)
        current_result = current_store.get(key="test_key", collection="default")
        assert current_result is None

    def test_get_missing_key(self, wrapper: MigrationWrapper) -> None:
        """Test getting a missing key returns None."""
        result = wrapper.get(key="missing_key", collection="default")
        assert result is None

    def test_migrate_on_read(self, migrating_wrapper: MigrationWrapper, legacy_store: MemoryStore, current_store: MemoryStore) -> None:
        """Test that migrate_on_read copies data from legacy to current."""
        legacy_store.put(key="test_key", value={"data": "legacy"}, collection="default", ttl=3600)

        result = migrating_wrapper.get(key="test_key", collection="default")
        assert result is not None
        assert result["data"] == "legacy"

        # Should have been migrated
        current_result = current_store.get(key="test_key", collection="default")
        assert current_result is not None
        assert current_result["data"] == "legacy"

        # Legacy should still have it (delete_after_migration=False)
        legacy_result = legacy_store.get(key="test_key", collection="default")
        assert legacy_result is not None

    def test_migrate_on_read_with_delete(self, legacy_store: MemoryStore, current_store: MemoryStore) -> None:
        """Test that delete_after_migration removes from legacy."""
        wrapper = MigrationWrapper(
            current_store=current_store, legacy_store=legacy_store, migrate_on_read=True, delete_after_migration=True, cache_size=100
        )

        legacy_store.put(key="test_key", value={"data": "legacy"}, collection="default")

        result = wrapper.get(key="test_key", collection="default")
        assert result is not None

        # Should have been deleted from legacy
        legacy_result = legacy_store.get(key="test_key", collection="default")
        assert legacy_result is None

    def test_cache_avoids_repeated_lookups(self, wrapper: MigrationWrapper, current_store: MemoryStore, legacy_store: MemoryStore) -> None:
        """Test that cache avoids repeated lookups."""
        current_store.put(key="test_key", value={"data": "current"}, collection="default")

        # First get - should cache
        result1 = wrapper.get(key="test_key", collection="default")
        assert result1 is not None

        # Check cache
        cached_location = wrapper._cache_get(key="test_key", collection="default")  # pyright: ignore[reportPrivateUsage]
        assert cached_location == "current"

        # Second get - should use cache (wouldn't check legacy even if we added to it)
        legacy_store.put(key="test_key", value={"data": "legacy"}, collection="default")
        result2 = wrapper.get(key="test_key", collection="default")
        assert result2 is not None
        assert result2["data"] == "current"  # Still from current, not legacy

    def test_cache_missing_keys(self, wrapper: MigrationWrapper) -> None:
        """Test that missing keys are cached."""
        # First get - should cache as missing
        result1 = wrapper.get(key="missing_key", collection="default")
        assert result1 is None

        # Check cache
        cached_location = wrapper._cache_get(key="missing_key", collection="default")  # pyright: ignore[reportPrivateUsage]
        assert cached_location == "missing"

        # Second get - should use cache
        result2 = wrapper.get(key="missing_key", collection="default")
        assert result2 is None

    def test_put_updates_cache(self, wrapper: MigrationWrapper, current_store: MemoryStore, legacy_store: MemoryStore) -> None:
        """Test that put updates the cache."""
        # Put initially in legacy
        legacy_store.put(key="test_key", value={"data": "legacy"}, collection="default")

        # Get - should cache as legacy
        wrapper.get(key="test_key", collection="default")
        assert wrapper._cache_get(key="test_key", collection="default") == "legacy"  # pyright: ignore[reportPrivateUsage]

        # Put - should update cache to current
        wrapper.put(key="test_key", value={"data": "new"}, collection="default")
        assert wrapper._cache_get(key="test_key", collection="default") == "current"  # pyright: ignore[reportPrivateUsage]

        # Get - should get from current, not legacy
        result = wrapper.get(key="test_key", collection="default")
        assert result is not None
        assert result["data"] == "new"

    def test_delete_from_both_stores(self, wrapper: MigrationWrapper, current_store: MemoryStore, legacy_store: MemoryStore) -> None:
        """Test that delete removes from both stores."""
        current_store.put(key="key1", value={"data": "current"}, collection="default")
        legacy_store.put(key="key2", value={"data": "legacy"}, collection="default")

        # Delete should remove from both
        deleted1 = wrapper.delete(key="key1", collection="default")
        deleted2 = wrapper.delete(key="key2", collection="default")

        assert deleted1 is True
        assert deleted2 is True

        # Verify deletion
        assert current_store.get(key="key1", collection="default") is None
        assert legacy_store.get(key="key2", collection="default") is None

    def test_get_many(self, wrapper: MigrationWrapper, current_store: MemoryStore, legacy_store: MemoryStore) -> None:
        """Test get_many with keys in different stores."""
        current_store.put(key="key1", value={"data": "current1"}, collection="default")
        legacy_store.put(key="key2", value={"data": "legacy2"}, collection="default")

        results = wrapper.get_many(keys=["key1", "key2", "key3"], collection="default")

        assert len(results) == 3
        assert results[0] is not None
        assert results[0]["data"] == "current1"
        assert results[1] is not None
        assert results[1]["data"] == "legacy2"
        assert results[2] is None

    def test_get_many_with_migration(
        self, migrating_wrapper: MigrationWrapper, legacy_store: MemoryStore, current_store: MemoryStore
    ) -> None:
        """Test get_many migrates keys from legacy to current."""
        legacy_store.put(key="key1", value={"data": "legacy1"}, collection="default")
        legacy_store.put(key="key2", value={"data": "legacy2"}, collection="default")

        results = migrating_wrapper.get_many(keys=["key1", "key2"], collection="default")

        assert len(results) == 2
        assert results[0] is not None
        assert results[1] is not None

        # Both should have been migrated
        current_result1 = current_store.get(key="key1", collection="default")
        current_result2 = current_store.get(key="key2", collection="default")
        assert current_result1 is not None
        assert current_result2 is not None

    def test_ttl_from_current(self, wrapper: MigrationWrapper, current_store: MemoryStore) -> None:
        """Test ttl from current store."""
        current_store.put(key="test_key", value={"data": "current"}, collection="default", ttl=3600)

        (value, ttl) = wrapper.ttl(key="test_key", collection="default")
        assert value is not None
        assert value["data"] == "current"
        assert ttl is not None
        assert ttl > 0

    def test_ttl_from_legacy(self, wrapper: MigrationWrapper, legacy_store: MemoryStore, current_store: MemoryStore) -> None:
        """Test ttl from legacy store."""
        legacy_store.put(key="test_key", value={"data": "legacy"}, collection="default", ttl=3600)

        (value, ttl) = wrapper.ttl(key="test_key", collection="default")
        assert value is not None
        assert value["data"] == "legacy"
        assert ttl is not None

        # Should NOT have been migrated (migrate_on_read=False)
        current_result = current_store.get(key="test_key", collection="default")
        assert current_result is None

    def test_ttl_with_migration(self, migrating_wrapper: MigrationWrapper, legacy_store: MemoryStore, current_store: MemoryStore) -> None:
        """Test ttl migrates from legacy to current."""
        legacy_store.put(key="test_key", value={"data": "legacy"}, collection="default", ttl=3600)

        (value, ttl) = migrating_wrapper.ttl(key="test_key", collection="default")
        assert value is not None
        assert ttl is not None

        # Should have been migrated with TTL preserved
        (current_value, current_ttl) = current_store.ttl(key="test_key", collection="default")
        assert current_value is not None
        assert current_ttl is not None

    def test_put_many(self, wrapper: MigrationWrapper, current_store: MemoryStore) -> None:
        """Test put_many writes to current store."""
        wrapper.put_many(keys=["key1", "key2"], values=[{"data": "value1"}, {"data": "value2"}], collection="default")

        # Verify in current store
        result1 = current_store.get(key="key1", collection="default")
        result2 = current_store.get(key="key2", collection="default")
        assert result1 is not None
        assert result2 is not None

    def test_delete_many(self, wrapper: MigrationWrapper, current_store: MemoryStore, legacy_store: MemoryStore) -> None:
        """Test delete_many removes from both stores."""
        current_store.put(key="key1", value={"data": "current"}, collection="default")
        legacy_store.put(key="key2", value={"data": "legacy"}, collection="default")

        count = wrapper.delete_many(keys=["key1", "key2"], collection="default")
        assert count == 2

        # Verify deletion
        assert current_store.get(key="key1", collection="default") is None
        assert legacy_store.get(key="key2", collection="default") is None

    def test_cache_disabled(self, current_store: MemoryStore, legacy_store: MemoryStore) -> None:
        """Test wrapper with caching disabled."""
        # Disable cache
        wrapper = MigrationWrapper(current_store=current_store, legacy_store=legacy_store, cache_size=0)

        current_store.put(key="test_key", value={"data": "current"}, collection="default")

        result = wrapper.get(key="test_key", collection="default")
        assert result is not None

        # Cache should be disabled
        assert not wrapper._cache_enabled  # pyright: ignore[reportPrivateUsage]

    def test_ttl_many(self, wrapper: MigrationWrapper, current_store: MemoryStore, legacy_store: MemoryStore) -> None:
        """Test ttl_many with keys in different stores."""
        current_store.put(key="key1", value={"data": "current1"}, collection="default", ttl=3600)
        legacy_store.put(key="key2", value={"data": "legacy2"}, collection="default", ttl=7200)

        results = wrapper.ttl_many(keys=["key1", "key2", "key3"], collection="default")

        assert len(results) == 3
        assert results[0][0] is not None  # key1 value
        assert results[0][1] is not None  # key1 ttl
        assert results[1][0] is not None  # key2 value
        assert results[1][1] is not None  # key2 ttl
        assert results[2][0] is None  # key3 missing
        assert results[2][1] is None  # key3 no ttl
