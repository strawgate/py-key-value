{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"py-key-value Documentation","text":"<p>Welcome to the py-key-value documentation! This library provides a pluggable interface for key-value stores with support for multiple backends, TTL handling, type safety, and extensible wrappers.</p>"},{"location":"#overview","title":"Overview","text":"<p>py-key-value is a Python framework that offers:</p> <ul> <li>Multiple backends: DynamoDB, Elasticsearch, Memcached, MongoDB, Redis,   RocksDB, Valkey, and In-memory, Disk, etc.</li> <li>TTL support: Automatic expiration handling across all store types</li> <li>Type-safe: Full type hints with Protocol-based interfaces</li> <li>Adapters: Pydantic model support, raise-on-missing behavior, etc.</li> <li>Wrappers: Statistics tracking, encryption, compression, and more</li> <li>Collection-based: Organize keys into logical collections/namespaces</li> <li>Pluggable architecture: Easy to add custom store implementations</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started - Installation and basic usage</li> <li>Stores - Detailed documentation for all stores</li> <li>Wrappers - Detailed documentation for all wrappers</li> <li>Adapters - Detailed documentation for all adapters</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install the async library:</p> <pre><code>pip install py-key-value-aio\n</code></pre> <p>Install with specific backend support:</p> <pre><code># Redis support\npip install py-key-value-aio[redis]\n\n# DynamoDB support\npip install py-key-value-aio[dynamodb]\n\n# All backends\npip install py-key-value-aio[all]\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\n\n# Create a store\nstore = MemoryStore()\n\n# Store a value with TTL\nawait store.put(\n    key=\"user:123\",\n    value={\"name\": \"Alice\", \"email\": \"alice@example.com\"},\n    collection=\"users\",\n    ttl=3600  # 1 hour\n)\n\n# Retrieve the value\nuser = await store.get(key=\"user:123\", collection=\"users\")\nprint(user)  # {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n</code></pre>"},{"location":"#for-framework-authors","title":"For Framework Authors","text":"<p>While key-value storage is valuable for individual projects, its true power emerges when framework authors use it as a pluggable abstraction layer.</p> <p>By coding your framework against the <code>AsyncKeyValue</code> protocol, you enable your users to choose their own storage backend without changing a single line of your framework code.</p> <p>Learn more about using py-key-value in your framework</p>"},{"location":"#project-links","title":"Project Links","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>Issue Tracker</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache License 2.0.</p>"},{"location":"adapters/","title":"Adapters","text":"<p>Adapters provide specialized interfaces for working with key-value stores. Unlike wrappers, adapters don't implement the <code>AsyncKeyValue</code> protocol - instead, they provide alternative APIs tailored for specific use cases.</p>"},{"location":"adapters/#available-adapters","title":"Available Adapters","text":"Adapter Description Safety Level DataclassAdapter Type-safe storage/retrieval of dataclass models \u2705 Safe (dataclass-only) BaseModelAdapter Type-safe storage/retrieval of Pydantic BaseModel instances \u2705 Safe (BaseModel-only) PydanticAdapter Storage/retrieval of any pydantic-serializable type \u26a0\ufe0f Less safe (any type) RaiseOnMissingAdapter Optional raise-on-missing behavior for get operations N/A"},{"location":"adapters/#choosing-the-right-adapter","title":"Choosing the Right Adapter","text":"<p>The three primary adapters offer different levels of type safety:</p> <ul> <li> <p>DataclassAdapter: Use when working with Python dataclasses. Provides   compile-time and runtime type safety for dataclass types only.</p> </li> <li> <p>BaseModelAdapter: Use when working with Pydantic BaseModel subclasses.   Provides compile-time and runtime type safety for BaseModel types only.</p> </li> <li> <p>PydanticAdapter: Use when you need maximum flexibility to store any   pydantic-serializable type (primitives, datetime, UUID, lists of primitives,   etc.). Less type-safe but more flexible.</p> </li> </ul>"},{"location":"adapters/#adapters-vs-wrappers","title":"Adapters vs Wrappers","text":"<p>Wrappers:</p> <ul> <li>Implement the <code>AsyncKeyValue</code> protocol</li> <li>Can be stacked and used anywhere a store is expected</li> <li>Add transparent functionality (compression, encryption, etc.)</li> <li>Don't change the API</li> </ul> <p>Adapters:</p> <ul> <li>Provide a different API</li> <li>Cannot be used in place of a store</li> <li>Add type safety and specialized behavior</li> <li>Transform how you interact with the store</li> </ul>"},{"location":"adapters/#adapter-details","title":"Adapter Details","text":""},{"location":"adapters/#dataclassadapter","title":"DataclassAdapter","text":"<p>The <code>DataclassAdapter</code> provides type-safe storage and retrieval of Python dataclass models. It automatically handles serialization and validation using Pydantic for validation.</p>"},{"location":"adapters/#use-cases","title":"Use Cases","text":"<ul> <li>Type-safe data storage with dataclasses</li> <li>Automatic validation on retrieval</li> <li>Working with Python's native dataclass decorator</li> <li>Ensuring data integrity</li> </ul>"},{"location":"adapters/#basic-example","title":"Basic Example","text":"<pre><code>from dataclasses import dataclass\nfrom key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.adapters.dataclass import DataclassAdapter\n\n@dataclass\nclass User:\n    name: str\n    email: str\n    age: int\n\n# Create adapter\nadapter = DataclassAdapter(\n    key_value=MemoryStore(),\n    dataclass_type=User\n)\n\n# Store a user (type-safe)\nuser = User(name=\"Alice\", email=\"alice@example.com\", age=30)\nawait adapter.put(key=\"user:123\", value=user, collection=\"users\")\n\n# Retrieve and get a validated model\nretrieved_user = await adapter.get(key=\"user:123\", collection=\"users\")\nif retrieved_user:\n    print(retrieved_user.name)  # Type-safe: \"Alice\"\n    print(retrieved_user.email)  # Type-safe: \"alice@example.com\"\n</code></pre>"},{"location":"adapters/#basemodeladapter","title":"BaseModelAdapter","text":"<p>The <code>BaseModelAdapter</code> provides type-safe storage and retrieval of Pydantic BaseModel instances. It's the recommended adapter for Pydantic models because it enforces type safety at both compile-time and runtime.</p>"},{"location":"adapters/#key_value.aio.adapters.base_model.BaseModelAdapter","title":"BaseModelAdapter","text":"<p>               Bases: <code>BasePydanticAdapter[T]</code></p> <p>Adapter around a KVStore-compliant Store that allows type-safe persistence of Pydantic BaseModels.</p> <p>This adapter is constrained to BaseModel subclasses and sequences of BaseModels, providing a safe, type-checked interface for Pydantic model persistence.</p>"},{"location":"adapters/#key_value.aio.adapters.base_model.BaseModelAdapter._default_collection","title":"_default_collection  <code>instance-attribute</code>","text":"<pre><code>_default_collection = default_collection\n</code></pre>"},{"location":"adapters/#key_value.aio.adapters.base_model.BaseModelAdapter._key_value","title":"_key_value  <code>instance-attribute</code>","text":"<pre><code>_key_value = key_value\n</code></pre>"},{"location":"adapters/#key_value.aio.adapters.base_model.BaseModelAdapter._needs_wrapping","title":"_needs_wrapping  <code>instance-attribute</code>","text":"<pre><code>_needs_wrapping = origin is list\n</code></pre>"},{"location":"adapters/#key_value.aio.adapters.base_model.BaseModelAdapter._raise_on_validation_error","title":"_raise_on_validation_error  <code>instance-attribute</code>","text":"<pre><code>_raise_on_validation_error = raise_on_validation_error\n</code></pre>"},{"location":"adapters/#key_value.aio.adapters.base_model.BaseModelAdapter._type_adapter","title":"_type_adapter  <code>instance-attribute</code>","text":"<pre><code>_type_adapter = TypeAdapter[T](pydantic_model)\n</code></pre>"},{"location":"adapters/#key_value.aio.adapters.base_model.BaseModelAdapter.__init__","title":"__init__","text":"<pre><code>__init__(\n    key_value,\n    pydantic_model,\n    default_collection=None,\n    raise_on_validation_error=False,\n)\n</code></pre> <p>Create a new BaseModelAdapter.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The KVStore to use.</p> required <code>pydantic_model</code> <code>type[T]</code> <p>The Pydantic model to use. Can be a single BaseModel subclass or list[BaseModel].</p> required <code>default_collection</code> <code>str | None</code> <p>The default collection to use.</p> <code>None</code> <code>raise_on_validation_error</code> <code>bool</code> <p>Whether to raise a DeserializationError if validation fails during reads. Otherwise,                        calls will return None if validation fails.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If pydantic_model is a sequence type other than list (e.g., tuple is not supported).</p>"},{"location":"adapters/#key_value.aio.adapters.base_model.BaseModelAdapter._get_model_type_name","title":"_get_model_type_name","text":"<pre><code>_get_model_type_name()\n</code></pre> <p>Return the model type name for error messages.</p>"},{"location":"adapters/#use-cases_1","title":"Use Cases","text":"<ul> <li>Type-safe storage of Pydantic BaseModel instances</li> <li>When you want compile-time type checking for model types</li> <li>Projects using Pydantic for data validation</li> <li>Ensuring only BaseModel subclasses are stored</li> </ul>"},{"location":"adapters/#basic-example_1","title":"Basic Example","text":"<pre><code>from pydantic import BaseModel\nfrom key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.adapters.base_model import BaseModelAdapter\n\nclass User(BaseModel):\n    name: str\n    email: str\n    age: int\n\n# Create adapter\nadapter = BaseModelAdapter(\n    key_value=MemoryStore(),\n    pydantic_model=User\n)\n\n# Store a user (type-safe)\nuser = User(name=\"Alice\", email=\"alice@example.com\", age=30)\nawait adapter.put(key=\"user:123\", value=user, collection=\"users\")\n\n# Retrieve and get a validated model\nretrieved_user = await adapter.get(key=\"user:123\", collection=\"users\")\nif retrieved_user:\n    print(retrieved_user.name)  # Type-safe: \"Alice\"\n    print(retrieved_user.email)  # Type-safe: \"alice@example.com\"\n</code></pre>"},{"location":"adapters/#storing-lists-of-models","title":"Storing Lists of Models","text":"<p>The <code>BaseModelAdapter</code> supports storing lists of BaseModel instances:</p> <pre><code>from pydantic import BaseModel\nfrom key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.adapters.base_model import BaseModelAdapter\n\nclass User(BaseModel):\n    name: str\n    email: str\n\n# Create adapter for list of users\nadapter = BaseModelAdapter(\n    key_value=MemoryStore(),\n    pydantic_model=list[User]\n)\n\n# Store a list of users\nusers = [\n    User(name=\"Alice\", email=\"alice@example.com\"),\n    User(name=\"Bob\", email=\"bob@example.com\"),\n]\nawait adapter.put(key=\"all-users\", value=users, collection=\"users\")\n\n# Retrieve the list\nretrieved_users = await adapter.get(key=\"all-users\", collection=\"users\")\nif retrieved_users:\n    for user in retrieved_users:\n        print(user.name)  # Type-safe access\n</code></pre>"},{"location":"adapters/#type-safety-benefits","title":"Type Safety Benefits","text":"<p>The <code>BaseModelAdapter</code> enforces that only BaseModel subclasses can be used:</p> <pre><code>from pydantic import BaseModel\nfrom key_value.aio.adapters.base_model import BaseModelAdapter\n\nclass User(BaseModel):\n    name: str\n\n# \u2705 This works - User is a BaseModel\nadapter = BaseModelAdapter(pydantic_model=User, key_value=store)\n\n# \u2705 This works - list[User] where User is a BaseModel\nadapter = BaseModelAdapter(pydantic_model=list[User], key_value=store)\n\n# \u274c This fails at runtime - int is not a BaseModel\nadapter = BaseModelAdapter(pydantic_model=int, key_value=store)  # TypeError!\n\n# \u274c This fails at runtime - list[int] inner type is not a BaseModel\nadapter = BaseModelAdapter(pydantic_model=list[int], key_value=store)  # TypeError!\n</code></pre>"},{"location":"adapters/#pydanticadapter","title":"PydanticAdapter","text":"<p>The <code>PydanticAdapter</code> provides storage and retrieval of any pydantic-serializable type. Unlike <code>BaseModelAdapter</code>, it accepts primitives, collections, datetime objects, and more\u2014not just BaseModel subclasses.</p>"},{"location":"adapters/#key_value.aio.adapters.pydantic.PydanticAdapter","title":"PydanticAdapter","text":"<p>               Bases: <code>BasePydanticAdapter[T]</code></p> <p>Adapter for persisting any pydantic-serializable type.</p> <p>This is the \"less safe\" adapter that accepts any Python type that Pydantic can serialize. Unlike BaseModelAdapter (which is constrained to BaseModel types), this adapter can handle: - Pydantic BaseModel instances - Dataclasses (standard and Pydantic) - TypedDict - Primitive types (int, str, float, bool, etc.) - Collection types (list, dict, set, tuple, etc.) - Datetime and other common types</p> <p>Types that serialize to dicts (BaseModel, dataclass, TypedDict, dict) are stored directly. Other types are wrapped in {\"items\": value} to ensure consistent dict-based storage.</p>"},{"location":"adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._default_collection","title":"_default_collection  <code>instance-attribute</code>","text":"<pre><code>_default_collection = default_collection\n</code></pre>"},{"location":"adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._key_value","title":"_key_value  <code>instance-attribute</code>","text":"<pre><code>_key_value = key_value\n</code></pre>"},{"location":"adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._needs_wrapping","title":"_needs_wrapping  <code>instance-attribute</code>","text":"<pre><code>_needs_wrapping = _check_needs_wrapping()\n</code></pre>"},{"location":"adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._raise_on_validation_error","title":"_raise_on_validation_error  <code>instance-attribute</code>","text":"<pre><code>_raise_on_validation_error = raise_on_validation_error\n</code></pre>"},{"location":"adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._type_adapter","title":"_type_adapter  <code>instance-attribute</code>","text":"<pre><code>_type_adapter = TypeAdapter[T](pydantic_model)\n</code></pre>"},{"location":"adapters/#key_value.aio.adapters.pydantic.PydanticAdapter.__init__","title":"__init__","text":"<pre><code>__init__(\n    key_value,\n    pydantic_model,\n    default_collection=None,\n    raise_on_validation_error=False,\n)\n</code></pre> <p>Create a new PydanticAdapter.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The KVStore to use.</p> required <code>pydantic_model</code> <code>TypeForm[T]</code> <p>The type to serialize/deserialize. Can be any pydantic-serializable type.</p> required <code>default_collection</code> <code>str | None</code> <p>The default collection to use.</p> <code>None</code> <code>raise_on_validation_error</code> <code>bool</code> <p>Whether to raise a DeserializationError if validation fails during reads.                        Otherwise, calls will return None if validation fails.</p> <code>False</code>"},{"location":"adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._check_needs_wrapping","title":"_check_needs_wrapping","text":"<pre><code>_check_needs_wrapping()\n</code></pre> <p>Check if a type needs to be wrapped in {\"items\": ...} for storage.</p> <p>Types that serialize to dicts don't need wrapping. Other types do.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the type needs wrapping, False otherwise.</p>"},{"location":"adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._get_model_type_name","title":"_get_model_type_name","text":"<pre><code>_get_model_type_name()\n</code></pre> <p>Return the model type name for error messages.</p>"},{"location":"adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._serializes_to_dict","title":"_serializes_to_dict","text":"<pre><code>_serializes_to_dict()\n</code></pre> <p>Check if a type serializes to a dict by inspecting the TypeAdapter's JSON schema.</p> <p>This uses Pydantic's TypeAdapter.json_schema() to reliably determine the output structure. Types that produce a JSON object (schema type \"object\") are dict-serializable.</p> <p>Uses a custom schema generator to skip fields that can't be represented in JSON schema (e.g., Callable fields), avoiding PydanticInvalidForJsonSchema errors.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the type serializes to a dict (JSON object), False otherwise.</p>"},{"location":"adapters/#use-cases_2","title":"Use Cases","text":"<ul> <li>Storing primitive types (int, str, float, bool)</li> <li>Storing datetime, UUID, Decimal, and other common types</li> <li>Storing lists of primitives (e.g., <code>list[int]</code>, <code>list[str]</code>)</li> <li>Maximum flexibility when type constraints aren't needed</li> <li>Working with any pydantic-serializable type</li> </ul>"},{"location":"adapters/#basic-example_2","title":"Basic Example","text":"<pre><code>from pydantic import BaseModel\nfrom key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.adapters.pydantic import PydanticAdapter\n\nclass User(BaseModel):\n    name: str\n    email: str\n    age: int\n\n# Create adapter\nadapter = PydanticAdapter(\n    key_value=MemoryStore(),\n    pydantic_model=User\n)\n\n# Store a user (type-safe)\nuser = User(name=\"Alice\", email=\"alice@example.com\", age=30)\nawait adapter.put(key=\"user:123\", value=user, collection=\"users\")\n\n# Retrieve and get a validated model\nretrieved_user = await adapter.get(key=\"user:123\", collection=\"users\")\nif retrieved_user:\n    print(retrieved_user.name)  # Type-safe: \"Alice\"\n    print(retrieved_user.email)  # Type-safe: \"alice@example.com\"\n</code></pre>"},{"location":"adapters/#storing-lists-of-models_1","title":"Storing Lists of Models","text":"<p>The <code>PydanticAdapter</code> supports storing lists of Pydantic models:</p> <pre><code>from pydantic import BaseModel\nfrom key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.adapters.pydantic import PydanticAdapter\n\nclass User(BaseModel):\n    name: str\n    email: str\n\n# Create adapter for list of users\nadapter = PydanticAdapter(\n    key_value=MemoryStore(),\n    pydantic_model=list[User]\n)\n\n# Store a list of users\nusers = [\n    User(name=\"Alice\", email=\"alice@example.com\"),\n    User(name=\"Bob\", email=\"bob@example.com\"),\n]\nawait adapter.put(key=\"all-users\", value=users, collection=\"users\")\n\n# Retrieve the list\nretrieved_users = await adapter.get(key=\"all-users\", collection=\"users\")\nif retrieved_users:\n    for user in retrieved_users:\n        print(user.name)  # Type-safe access\n</code></pre>"},{"location":"adapters/#validation-error-handling","title":"Validation Error Handling","text":"<p>By default, the adapter returns <code>None</code> if validation fails. You can configure it to raise an error instead:</p> <pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.adapters.pydantic import PydanticAdapter\nfrom key_value.aio.errors import DeserializationError\n\nadapter = PydanticAdapter(\n    key_value=MemoryStore(),\n    pydantic_model=User,\n    raise_on_validation_error=True\n)\n\n# Manually corrupt data in the underlying store\nawait adapter._key_value.put(\n    key=\"user:123\",\n    value={\"name\": \"Alice\"},  # Missing required 'email' field\n    collection=\"users\"\n)\n\ntry:\n    user = await adapter.get(key=\"user:123\", collection=\"users\")\nexcept DeserializationError as e:\n    print(f\"Validation failed: {e}\")\n</code></pre>"},{"location":"adapters/#default-collection","title":"Default Collection","text":"<p>Set a default collection to avoid repeating it in every call:</p> <pre><code>adapter = PydanticAdapter(\n    key_value=MemoryStore(),\n    pydantic_model=User,\n    default_collection=\"users\"\n)\n\n# No need to specify collection\nawait adapter.put(key=\"user:123\", value=user)\nuser = await adapter.get(key=\"user:123\")\n</code></pre>"},{"location":"adapters/#batch-operations","title":"Batch Operations","text":"<p>The <code>PydanticAdapter</code> supports batch operations for better performance:</p> <pre><code># Store multiple users\nusers = [\n    User(name=\"Alice\", email=\"alice@example.com\", age=30),\n    User(name=\"Bob\", email=\"bob@example.com\", age=25),\n    User(name=\"Charlie\", email=\"charlie@example.com\", age=35),\n]\n\nawait adapter.put_many(\n    keys=[\"user:1\", \"user:2\", \"user:3\"],\n    values=users,\n    collection=\"users\"\n)\n\n# Retrieve multiple users\nretrieved = await adapter.get_many(\n    keys=[\"user:1\", \"user:2\", \"user:3\"],\n    collection=\"users\"\n)\n\nfor user in retrieved:\n    if user:\n        print(user.name)\n</code></pre>"},{"location":"adapters/#ttl-support","title":"TTL Support","text":"<p>The <code>PydanticAdapter</code> supports TTL for automatic expiration:</p> <pre><code># Store with TTL\nawait adapter.put(\n    key=\"session:abc\",\n    value=session_data,\n    collection=\"sessions\",\n    ttl=3600  # Expires in 1 hour\n)\n\n# Get with TTL information\nsession, ttl = await adapter.ttl(key=\"session:abc\", collection=\"sessions\")\nif session:\n    print(f\"Session expires in {ttl} seconds\")\n</code></pre>"},{"location":"adapters/#complex-models","title":"Complex Models","text":"<p>The <code>PydanticAdapter</code> works with complex nested models:</p> <pre><code>from pydantic import BaseModel\nfrom datetime import datetime\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    country: str\n\nclass User(BaseModel):\n    name: str\n    email: str\n    address: Address\n    created_at: datetime\n\nadapter = PydanticAdapter(\n    key_value=MemoryStore(),\n    pydantic_model=User\n)\n\nuser = User(\n    name=\"Alice\",\n    email=\"alice@example.com\",\n    address=Address(\n        street=\"123 Main St\",\n        city=\"New York\",\n        country=\"USA\"\n    ),\n    created_at=datetime.now()\n)\n\nawait adapter.put(key=\"user:123\", value=user, collection=\"users\")\nretrieved = await adapter.get(key=\"user:123\", collection=\"users\")\n\nif retrieved:\n    print(retrieved.address.city)  # Type-safe: \"New York\"\n</code></pre>"},{"location":"adapters/#storing-non-model-types","title":"Storing Non-Model Types","text":"<p>The <code>PydanticAdapter</code> can store types that <code>BaseModelAdapter</code> cannot:</p> <pre><code>from datetime import datetime\nfrom uuid import UUID\nfrom key_value.aio.adapters.pydantic import PydanticAdapter\n\n# \u2705 Store primitives\nint_adapter = PydanticAdapter(key_value=store, pydantic_model=int)\nawait int_adapter.put(key=\"count\", value=42, collection=\"stats\")\n\n# \u2705 Store datetime\ndatetime_adapter = PydanticAdapter(key_value=store, pydantic_model=datetime)\nawait datetime_adapter.put(key=\"timestamp\", value=datetime.now(), collection=\"events\")\n\n# \u2705 Store UUID\nuuid_adapter = PydanticAdapter(key_value=store, pydantic_model=UUID)\nawait uuid_adapter.put(key=\"id\", value=UUID(\"12345678-1234-5678-1234-567812345678\"))\n\n# \u2705 Store list of primitives\nlist_adapter = PydanticAdapter(key_value=store, pydantic_model=list[int])\nawait list_adapter.put(key=\"scores\", value=[10, 20, 30], collection=\"game\")\n</code></pre> <p>Note: <code>BaseModelAdapter</code> would reject all of these types because they're not BaseModel subclasses.</p>"},{"location":"adapters/#basemodeladapter-vs-pydanticadapter-when-to-use-each","title":"BaseModelAdapter vs PydanticAdapter: When to Use Each","text":""},{"location":"adapters/#use-basemodeladapter-when","title":"Use BaseModelAdapter When","text":"<p>\u2705 You're working exclusively with Pydantic BaseModel subclasses \u2705 You want compile-time type safety \u2705 You want runtime validation that only BaseModel types are stored \u2705 You prefer strict type constraints</p> <p>Example Use Case: A user management system where all entities are Pydantic models:</p> <pre><code>from pydantic import BaseModel, EmailStr\nfrom key_value.aio.adapters.base_model import BaseModelAdapter\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\nclass Organization(BaseModel):\n    id: int\n    name: str\n    users: list[User]\n\n# Type-safe: only User instances allowed\nuser_adapter = BaseModelAdapter[User](\n    key_value=store,\n    pydantic_model=User\n)\n\n# Type-safe: only Organization instances allowed\norg_adapter = BaseModelAdapter[Organization](\n    key_value=store,\n    pydantic_model=Organization\n)\n\n# \u2705 This works - User is a BaseModel\nawait user_adapter.put(key=\"user:1\", value=User(id=1, name=\"Alice\", email=\"alice@example.com\"))\n\n# \u274c This fails at type-check time - wrong type\n# await user_adapter.put(key=\"user:1\", value=\"not a user\")\n</code></pre>"},{"location":"adapters/#use-pydanticadapter-when","title":"Use PydanticAdapter When","text":"<p>\u2705 You need to store primitive types (int, str, datetime, UUID, etc.) \u2705 You need to store lists of primitives (<code>list[int]</code>, <code>list[str]</code>) \u2705 You're storing a mix of different types \u2705 You need maximum flexibility \u2705 Type constraints would be too restrictive</p> <p>Example Use Case: A caching system that stores various data types:</p> <pre><code>from datetime import datetime\nfrom uuid import UUID\nfrom pydantic import BaseModel\nfrom key_value.aio.adapters.pydantic import PydanticAdapter\n\n# Different adapters for different types\nsession_adapter = PydanticAdapter[UUID](key_value=store, pydantic_model=UUID)\ntimestamp_adapter = PydanticAdapter[datetime](key_value=store, pydantic_model=datetime)\ncounter_adapter = PydanticAdapter[int](key_value=store, pydantic_model=int)\ntags_adapter = PydanticAdapter[list[str]](key_value=store, pydantic_model=list[str])\n\n# \u2705 All of these work with PydanticAdapter\nawait session_adapter.put(key=\"session:abc\", value=UUID(\"...\"))\nawait timestamp_adapter.put(key=\"last-login:user:1\", value=datetime.now())\nawait counter_adapter.put(key=\"views:page:1\", value=1000)\nawait tags_adapter.put(key=\"tags:post:1\", value=[\"python\", \"tutorial\"])\n\n# \u274c BaseModelAdapter would reject all of these (not BaseModel types)\n</code></pre>"},{"location":"adapters/#side-by-side-comparison","title":"Side-by-Side Comparison","text":"<pre><code>from pydantic import BaseModel\nfrom key_value.aio.adapters.base_model import BaseModelAdapter\nfrom key_value.aio.adapters.pydantic import PydanticAdapter\n\nclass Product(BaseModel):\n    name: str\n    price: float\n\n# BaseModelAdapter: Strict type safety\nbase_adapter = BaseModelAdapter[Product](\n    key_value=store,\n    pydantic_model=Product\n)\n\n# PydanticAdapter: Flexible\npydantic_adapter = PydanticAdapter[Product](\n    key_value=store,\n    pydantic_model=Product\n)\n\n# Both can store Product instances\nproduct = Product(name=\"Widget\", price=29.99)\nawait base_adapter.put(key=\"product:1\", value=product)\nawait pydantic_adapter.put(key=\"product:1\", value=product)\n\n# But only PydanticAdapter can be used with non-BaseModel types:\n\n# \u2705 PydanticAdapter can do this\nprice_adapter = PydanticAdapter[float](key_value=store, pydantic_model=float)\nawait price_adapter.put(key=\"price:product:1\", value=29.99)\n\n# \u274c BaseModelAdapter cannot\n# base_adapter = BaseModelAdapter[float](...) # TypeError at runtime!\n</code></pre>"},{"location":"adapters/#key-differences","title":"Key Differences","text":"Feature BaseModelAdapter PydanticAdapter Accepted Types Only <code>BaseModel</code> or <code>list[BaseModel]</code> Any pydantic-serializable type Type Safety Compile-time + runtime validation Runtime serialization only Primitives \u274c No (int, str, float, etc.) \u2705 Yes DateTime/UUID \u274c No \u2705 Yes BaseModel \u2705 Yes \u2705 Yes List of Primitives \u274c No \u2705 Yes Type Constraints Strict Flexible Use Case BaseModel-only projects Mixed-type storage"},{"location":"adapters/#raiseonmissingadapter","title":"RaiseOnMissingAdapter","text":"<p>The <code>RaiseOnMissingAdapter</code> changes the behavior of <code>get</code> operations to raise an error instead of returning <code>None</code> when a key is not found.</p>"},{"location":"adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter","title":"RaiseOnMissingAdapter","text":"<p>Adapter around a KVStore that raises on missing values for get/get_many/ttl/ttl_many.</p> <p>When <code>raise_on_missing=True</code>, methods raise <code>MissingKeyError</code> instead of returning None.</p>"},{"location":"adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.__init__","title":"__init__","text":"<pre><code>__init__(key_value)\n</code></pre>"},{"location":"adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre> <p>Delete a key-value pair from the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to delete the value from.</p> required <code>collection</code> <code>str | None</code> <p>The collection to delete the value from. If no collection is provided, it will use the default collection.</p> <code>None</code>"},{"location":"adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre> <p>Delete multiple key-value pairs from the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Sequence[str]</code> <p>The keys to delete the values from.</p> required <code>collection</code> <code>str | None</code> <p>The collection to delete keys from. If no collection is provided, it will use the default collection.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of keys deleted.</p>"},{"location":"adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.get","title":"get  <code>async</code>","text":"<pre><code>get(\n    key: str,\n    *,\n    collection: str | None = None,\n    raise_on_missing: Literal[False] = False,\n) -&gt; dict[str, Any] | None\n</code></pre><pre><code>get(\n    key: str, *, collection: str | None = None, raise_on_missing: Literal[True]\n) -&gt; dict[str, Any]\n</code></pre> <pre><code>get(key, *, collection=None, raise_on_missing=False)\n</code></pre> <p>Retrieve a value by key from the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve the value from.</p> required <code>collection</code> <code>str | None</code> <p>The collection to retrieve the value from. If no collection is provided, it will use the default collection.</p> <code>None</code> <code>raise_on_missing</code> <code>bool</code> <p>Whether to raise a MissingKeyError if the key is not found.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>The value associated with the key. If the key is not found, None will be returned.</p>"},{"location":"adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(\n    keys: Sequence[str],\n    *,\n    collection: str | None = None,\n    raise_on_missing: Literal[False] = False,\n) -&gt; list[dict[str, Any] | None]\n</code></pre><pre><code>get_many(\n    keys: Sequence[str],\n    *,\n    collection: str | None = None,\n    raise_on_missing: Literal[True],\n) -&gt; list[dict[str, Any]]\n</code></pre> <pre><code>get_many(keys, *, collection=None, raise_on_missing=False)\n</code></pre> <p>Retrieve multiple values by key from the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Sequence[str]</code> <p>The keys to retrieve the values from.</p> required <code>collection</code> <code>str | None</code> <p>The collection to retrieve keys from. If no collection is provided, it will use the default collection.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]] | list[dict[str, Any] | None]</code> <p>The values for the keys, or [] if the key is not found.</p>"},{"location":"adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre> <p>Store a key-value pair in the specified collection with optional TTL.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to store the value in.</p> required <code>value</code> <code>Mapping[str, Any]</code> <p>The value to store.</p> required <code>collection</code> <code>str | None</code> <p>The collection to store the value in. If no collection is provided, it will use the default collection.</p> <code>None</code> <code>ttl</code> <code>SupportsFloat | None</code> <p>The optional time-to-live (expiry duration) for the key-value pair. Defaults to no TTL. Note: The backend store will convert the provided format to its own internal format.</p> <code>None</code>"},{"location":"adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre> <p>Store multiple key-value pairs in the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Sequence[str]</code> <p>The keys to store the values in.</p> required <code>values</code> <code>Sequence[Mapping[str, Any]]</code> <p>The values to store.</p> required <code>collection</code> <code>str | None</code> <p>The collection to store keys in. If no collection is provided, it will use the default collection.</p> <code>None</code> <code>ttl</code> <code>SupportsFloat | None</code> <p>The optional time-to-live (expiry duration) for all key-value pairs. The same TTL will be applied to all items in the batch. Defaults to no TTL. Note: The backend store will convert the provided format to its own internal format.</p> <code>None</code>"},{"location":"adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(\n    key: str,\n    *,\n    collection: str | None = None,\n    raise_on_missing: Literal[False] = False,\n) -&gt; tuple[dict[str, Any] | None, float | None]\n</code></pre><pre><code>ttl(\n    key: str, *, collection: str | None = None, raise_on_missing: Literal[True]\n) -&gt; tuple[dict[str, Any], float | None]\n</code></pre> <pre><code>ttl(key, *, collection=None, raise_on_missing=False)\n</code></pre> <p>Retrieve the value and TTL information for a key-value pair from the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve the TTL information from.</p> required <code>collection</code> <code>str | None</code> <p>The collection to retrieve the TTL information from. If no collection is provided,         it will use the default collection.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[dict[str, Any] | None, float | None]</code> <p>The value and TTL information for the key. If the key is not found, (None, None) will be returned.</p>"},{"location":"adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(\n    keys: Sequence[str],\n    *,\n    collection: str | None = None,\n    raise_on_missing: Literal[False] = False,\n) -&gt; list[tuple[dict[str, Any] | None, float | None]]\n</code></pre><pre><code>ttl_many(\n    keys: Sequence[str],\n    *,\n    collection: str | None = None,\n    raise_on_missing: Literal[True],\n) -&gt; list[tuple[dict[str, Any], float | None]]\n</code></pre> <pre><code>ttl_many(keys, *, collection=None, raise_on_missing=False)\n</code></pre> <p>Retrieve multiple values and TTL information by key from the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Sequence[str]</code> <p>The keys to retrieve the values and TTL information from.</p> required <code>collection</code> <code>str | None</code> <p>The collection to retrieve keys from. If no collection is provided, it will use the default collection.</p> <code>None</code>"},{"location":"adapters/#use-cases_3","title":"Use Cases","text":"<ul> <li>Enforcing required data</li> <li>Fail-fast behavior</li> <li>APIs where missing data is an error</li> </ul>"},{"location":"adapters/#example","title":"Example","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.adapters.raise_on_missing import RaiseOnMissingAdapter\nfrom key_value.aio.errors import MissingKeyError\n\nadapter = RaiseOnMissingAdapter(\n    key_value=MemoryStore()\n)\n\n# Store a value\nawait adapter.put(key=\"user:123\", value={\"name\": \"Alice\"}, collection=\"users\")\n\n# Get existing key - works normally\nuser = await adapter.get(key=\"user:123\", collection=\"users\")\nprint(user)  # {\"name\": \"Alice\"}\n\n# Get missing key - raises error\ntry:\n    user = await adapter.get(key=\"user:999\", collection=\"users\")\nexcept KeyNotFoundError as e:\n    print(f\"Key not found: {e}\")\n</code></pre>"},{"location":"adapters/#batch-operations_1","title":"Batch Operations","text":"<p>The <code>RaiseOnMissingAdapter</code> also affects batch operations:</p> <pre><code># If any key is missing, raises KeyNotFoundError\ntry:\n    users = await adapter.get_many(\n        keys=[\"user:1\", \"user:999\", \"user:3\"],\n        collection=\"users\"\n    )\nexcept KeyNotFoundError as e:\n    print(f\"One or more keys not found: {e}\")\n</code></pre>"},{"location":"adapters/#combining-adapters-and-wrappers","title":"Combining Adapters and Wrappers","text":"<p>You can combine adapters with wrappers by wrapping the store before passing it to the adapter:</p> <pre><code>from pydantic import BaseModel\nfrom key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.encryption.fernet import FernetEncryptionWrapper\nfrom key_value.aio.wrappers.compression import CompressionWrapper\nfrom key_value.aio.adapters.pydantic import PydanticAdapter\nfrom cryptography.fernet import Fernet\n\nclass User(BaseModel):\n    name: str\n    email: str\n\n# Create encrypted + compressed store\nwrapped_store = CompressionWrapper(\n    key_value=FernetEncryptionWrapper(\n        key_value=MemoryStore(),\n        fernet=Fernet(Fernet.generate_key())\n    )\n)\n\n# Wrap with PydanticAdapter for type safety\nadapter = PydanticAdapter(\n    key_value=wrapped_store,\n    pydantic_model=User\n)\n\n# Now you have type-safe, encrypted, and compressed storage!\nawait adapter.put(key=\"user:123\", value=User(name=\"Alice\", email=\"alice@example.com\"))\n</code></pre>"},{"location":"adapters/#creating-custom-adapters","title":"Creating Custom Adapters","text":"<p>To create a custom adapter, wrap an <code>AsyncKeyValue</code> instance and provide your own API:</p> <pre><code>from key_value.aio.protocols.key_value import AsyncKeyValue\n\nclass CustomAdapter:\n    def __init__(self, key_value: AsyncKeyValue):\n        self._key_value = key_value\n\n    async def custom_method(self, key: str) -&gt; dict:\n        # Implement custom logic\n        value = await self._key_value.get(key=key, collection=\"custom\")\n        if value is None:\n            return {}\n        return value\n</code></pre> <p>See the API Reference for complete adapter documentation.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with py-key-value, from installation to basic usage patterns.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#basic-installation","title":"Basic Installation","text":"<p>Install the async library:</p> <pre><code>pip install py-key-value-aio\n</code></pre>"},{"location":"getting-started/#backend-specific-installation","title":"Backend-Specific Installation","text":"<p>Install with specific backend support:</p> <pre><code># Redis support\npip install py-key-value-aio[redis]\n\n# DynamoDB support\npip install py-key-value-aio[dynamodb]\n\n# Elasticsearch support\npip install py-key-value-aio[elasticsearch]\n\n# MongoDB support\npip install py-key-value-aio[mongodb]\n\n# Firestore support\npip install py-key-value-aio[firestore]\n\n# All backends\npip install py-key-value-aio[all]\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#creating-a-store","title":"Creating a Store","text":"<p>The simplest way to get started is with the <code>MemoryStore</code>:</p> <pre><code>from key_value.aio.stores.memory import MemoryStore\n\nstore = MemoryStore()\n</code></pre>"},{"location":"getting-started/#storing-values","title":"Storing Values","text":"<p>Store a value with the <code>put</code> method:</p> <pre><code>await store.put(\n    key=\"user:123\",\n    value={\"name\": \"Alice\", \"email\": \"alice@example.com\"},\n    collection=\"users\"\n)\n</code></pre>"},{"location":"getting-started/#retrieving-values","title":"Retrieving Values","text":"<p>Retrieve a value with the <code>get</code> method:</p> <pre><code>user = await store.get(key=\"user:123\", collection=\"users\")\nprint(user)  # {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n</code></pre>"},{"location":"getting-started/#ttl-support","title":"TTL Support","text":"<p>Set a TTL (time-to-live) for automatic expiration:</p> <pre><code>await store.put(\n    key=\"session:abc\",\n    value={\"user_id\": \"123\", \"expires\": \"2024-01-01\"},\n    collection=\"sessions\",\n    ttl=3600  # Expires in 1 hour\n)\n</code></pre>"},{"location":"getting-started/#deleting-values","title":"Deleting Values","text":"<p>Delete a value with the <code>delete</code> method:</p> <pre><code>deleted = await store.delete(key=\"user:123\", collection=\"users\")\nprint(deleted)  # True if the value was deleted, False otherwise\n</code></pre>"},{"location":"getting-started/#working-with-collections","title":"Working with Collections","text":"<p>Collections allow you to organize keys into logical namespaces:</p> <pre><code># Store users in the \"users\" collection\nawait store.put(\n    key=\"alice\",\n    value={\"name\": \"Alice\"},\n    collection=\"users\"\n)\n\n# Store sessions in the \"sessions\" collection\nawait store.put(\n    key=\"session-1\",\n    value={\"user_id\": \"alice\"},\n    collection=\"sessions\"\n)\n</code></pre>"},{"location":"getting-started/#batch-operations","title":"Batch Operations","text":"<p>Perform batch operations for better performance:</p> <pre><code># Put multiple values at once\nawait store.put_many(\n    keys=[\"user:1\", \"user:2\", \"user:3\"],\n    values=[\n        {\"name\": \"Alice\"},\n        {\"name\": \"Bob\"},\n        {\"name\": \"Charlie\"}\n    ],\n    collection=\"users\"\n)\n\n# Get multiple values at once\nusers = await store.get_many(\n    keys=[\"user:1\", \"user:2\", \"user:3\"],\n    collection=\"users\"\n)\n\n# Delete multiple values at once\ncount = await store.delete_many(\n    keys=[\"user:1\", \"user:2\", \"user:3\"],\n    collection=\"users\"\n)\n</code></pre>"},{"location":"getting-started/#using-different-backends","title":"Using Different Backends","text":""},{"location":"getting-started/#redis","title":"Redis","text":"<pre><code>from key_value.aio.stores.redis import RedisStore\n\nstore = RedisStore(url=\"redis://localhost:6379/0\")\n</code></pre>"},{"location":"getting-started/#dynamodb","title":"DynamoDB","text":"<pre><code>from key_value.aio.stores.dynamodb import DynamoDBStore\n\nstore = DynamoDBStore(\n    table_name=\"my-kv-store\",\n    region_name=\"us-east-1\"\n)\n</code></pre>"},{"location":"getting-started/#disk-storage","title":"Disk Storage","text":"<pre><code>from key_value.aio.stores.disk import DiskStore\n\nstore = DiskStore(directory=\"/path/to/storage\")\n</code></pre>"},{"location":"getting-started/#using-wrappers","title":"Using Wrappers","text":"<p>Wrappers add functionality to stores. They can be stacked for combined effects:</p> <pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.logging import LoggingWrapper\nfrom key_value.aio.wrappers.statistics import StatisticsWrapper\n\n# Create a store with logging and statistics\nstore = StatisticsWrapper(\n    LoggingWrapper(\n        MemoryStore()\n    )\n)\n\n# Use the store normally\nawait store.put(key=\"test\", value={\"data\": \"value\"})\n\n# Access statistics\nstats = store.get_statistics()\nprint(f\"Total puts: {stats.put.count}\")\n</code></pre> <p>See the Wrappers page for detailed documentation on all available wrappers.</p>"},{"location":"getting-started/#using-adapters","title":"Using Adapters","text":"<p>Adapters provide specialized interfaces for specific use cases:</p> <pre><code>from pydantic import BaseModel\nfrom key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.adapters.pydantic import PydanticAdapter\n\nclass User(BaseModel):\n    name: str\n    email: str\n\n# Create a type-safe adapter\nadapter = PydanticAdapter(\n    key_value=MemoryStore(),\n    pydantic_model=User\n)\n\n# Store and retrieve type-safe models\nawait adapter.put(\n    key=\"user:123\",\n    value=User(name=\"Alice\", email=\"alice@example.com\"),\n    collection=\"users\"\n)\n\nuser = await adapter.get(key=\"user:123\", collection=\"users\")\nprint(user.name)  # Type-safe access: \"Alice\"\n</code></pre> <p>See the Adapters page for detailed documentation on all available adapters.</p>"},{"location":"getting-started/#for-framework-authors","title":"For Framework Authors","text":"<p>If you're building a framework, you can use the <code>AsyncKeyValue</code> protocol to allow your users to plug in any backend:</p> <pre><code>from key_value.aio.protocols.key_value import AsyncKeyValue\n\nclass YourFramework:\n    def __init__(self, cache: AsyncKeyValue):\n        self.cache = cache\n\n    async def store_session(self, session_id: str, data: dict):\n        await self.cache.put(\n            key=f\"session:{session_id}\",\n            value=data,\n            collection=\"sessions\",\n            ttl=3600\n        )\n\n    async def get_session(self, session_id: str):\n        return await self.cache.get(\n            key=f\"session:{session_id}\",\n            collection=\"sessions\"\n        )\n</code></pre> <p>Your users can then choose their own backend:</p> <pre><code>from your_framework import YourFramework\nfrom key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.stores.redis import RedisStore\n\n# Development\nframework = YourFramework(cache=MemoryStore())\n\n# Production\nframework = YourFramework(\n    cache=RedisStore(url=\"redis://localhost:6379/0\")\n)\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about all available Wrappers</li> <li>Learn about all available Adapters</li> <li>Explore the API Reference</li> </ul>"},{"location":"stores/","title":"Stores","text":"<p>Stores are the core implementations of the <code>AsyncKeyValue</code> protocol. They provide the actual storage backend for your key-value data.</p>"},{"location":"stores/#store-categories","title":"Store Categories","text":"<p>Stores are organized into three categories based on their storage location and use case:</p> <ul> <li>Local Stores: In-memory or on-disk storage local to the application</li> <li>Secret Stores: Secure storage for sensitive data in OS secret stores</li> <li>Distributed Stores: Network-based storage for multi-node applications</li> </ul>"},{"location":"stores/#stability-levels","title":"Stability Levels","text":"<p>Each store has a stability rating that indicates the likelihood of backwards-incompatible changes to how data is stored:</p> <ul> <li>Stable: No planned backwards-incompatible changes</li> <li>Preview: Unlikely to change in backwards-incompatible ways</li> <li>Unstable: May change in backwards-incompatible ways</li> <li>N/A: Not applicable (e.g., in-memory stores)</li> </ul> <p>If you're using py-key-value for caching, stability may not matter. For long-term storage, prefer stable stores.</p>"},{"location":"stores/#local-stores","title":"Local Stores","text":"<p>Local stores are stored in memory or on disk, local to the application.</p> Store Stability Description Memory N/A Fast in-memory storage for development and caching Disk Stable Persistent file-based storage in a single file Disk (Per-Collection) Stable Persistent storage with separate files per collection DuckDB Unstable In-process SQL OLAP database with native JSON storage FileTree (test) Unstable Directory-based storage with JSON files for visual inspection Null (test) N/A No-op store for testing without side effects RocksDB Unstable High-performance embedded database Simple (test) N/A Simple in-memory store for testing Windows Registry Unstable Windows Registry-based storage"},{"location":"stores/#memorystore","title":"MemoryStore","text":"<p>Fast in-memory storage ideal for development, testing, and caching.</p> <pre><code>from key_value.aio.stores.memory import MemoryStore\n\nstore = MemoryStore()\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[memory]\n</code></pre> <p>Use Cases:</p> <ul> <li>Development and testing</li> <li>Fast caching</li> <li>Session storage</li> <li>Temporary data</li> </ul> <p>Characteristics:</p> <ul> <li>No persistence (data lost on restart)</li> <li>Extremely fast</li> <li>No external dependencies</li> <li>Thread-safe</li> </ul>"},{"location":"stores/#diskstore","title":"DiskStore","text":"<p>Persistent file-based storage using a single JSON file.</p> <pre><code>from key_value.aio.stores.disk import DiskStore\n\nstore = DiskStore(directory=\"./cache\")\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[disk]\n</code></pre> <p>Use Cases:</p> <ul> <li>Local caching with persistence</li> <li>Development environments</li> <li>Single-node applications</li> <li>Small datasets</li> </ul> <p>Characteristics:</p> <ul> <li>Persists across restarts</li> <li>Simple file format (JSON)</li> <li>Suitable for small to medium datasets</li> <li>All data in one file</li> </ul>"},{"location":"stores/#multidiskstore","title":"MultiDiskStore","text":"<p>Persistent storage with separate files per collection.</p> <pre><code>from key_value.aio.stores.multi_disk import MultiDiskStore\n\nstore = MultiDiskStore(directory=\"./cache\")\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[disk]\n</code></pre> <p>Use Cases:</p> <ul> <li>Organizing data by collection</li> <li>Better performance with many collections</li> <li>Easier to manage individual collections</li> </ul> <p>Characteristics:</p> <ul> <li>One file per collection</li> <li>Better suited for many collections</li> <li>Easier collection management</li> <li>JSON-based storage</li> </ul>"},{"location":"stores/#filetreestore","title":"FileTreeStore","text":"<p>Directory-based storage for visual inspection and debugging.</p> <pre><code>from key_value.aio.stores.filetree import FileTreeStore\n\nstore = FileTreeStore(directory=\"./debug-store\")\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[filetree]\n</code></pre> <p>Use Cases:</p> <ul> <li>Visual inspection of store contents</li> <li>Debugging store behavior</li> <li>Development and testing</li> <li>Understanding data structure</li> </ul> <p>Characteristics:</p> <ul> <li>Collections as directories</li> <li>Keys as JSON files (<code>{key}.json</code>)</li> <li>Human-readable filesystem layout</li> <li>Easy to inspect and modify</li> <li>NOT for production use</li> </ul> <p>Directory Structure:</p> <pre><code>{base_directory}/\n  {collection_1}/\n    {key_1}.json\n    {key_2}.json\n  {collection_2}/\n    {key_3}.json\n</code></pre> <p>Important Limitations:</p> <ul> <li>Poor performance with many keys</li> <li>No atomic operations</li> <li>No automatic cleanup of expired entries</li> <li>Filesystem path length constraints</li> <li>Subject to filesystem limitations</li> </ul> <p>When to Use:</p> <p>Use FileTreeStore when you need to:</p> <ul> <li>Visually inspect what's being stored</li> <li>Debug complex data structures</li> <li>Understand how the store organizes data</li> <li>Manually modify stored data for testing</li> </ul> <p>When NOT to Use:</p> <ul> <li>Production environments</li> <li>High-performance requirements</li> <li>Large datasets</li> <li>Concurrent access scenarios</li> </ul>"},{"location":"stores/#duckdbstore","title":"DuckDBStore","text":"<p>In-process SQL OLAP database with native JSON storage.</p> <pre><code>from key_value.aio.stores.duckdb import DuckDBStore\n\n# In-memory database (default)\nstore = DuckDBStore()\n\n# Persistent database\nstore = DuckDBStore(database_path=\"./my_store.duckdb\")\n\n# With existing connection\nimport duckdb\nconnection = duckdb.connect(\"./my_store.duckdb\")\nstore = DuckDBStore(connection=connection)\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[duckdb]\n</code></pre> <p>Use Cases:</p> <ul> <li>Analytics on stored key-value data</li> <li>Local development with SQL querying capabilities</li> <li>Applications needing both key-value and SQL access</li> <li>Data exploration and reporting</li> </ul> <p>Characteristics:</p> <ul> <li>Native JSON column support for queryable values</li> <li>In-memory or persistent storage</li> <li>Standard SQL access to stored data</li> <li>Efficient timestamp handling for TTL queries</li> <li>Stable storage format: Unstable</li> </ul> <p>Direct SQL Access:</p> <p>DuckDB allows you to query your key-value data directly with SQL:</p> <pre><code># After storing some data\nawait store.put(\"user:1\", {\"name\": \"Alice\", \"age\": 30}, collection=\"users\")\nawait store.put(\"user:2\", {\"name\": \"Bob\", \"age\": 25}, collection=\"users\")\n\n# Query directly via DuckDB\nresult = store._connection.execute(\"\"\"\n    SELECT key, value-&gt;&gt;'name' as name\n    FROM kv_entries\n    WHERE collection = 'users'\n\"\"\").fetchall()\n</code></pre>"},{"location":"stores/#rocksdbstore","title":"RocksDBStore","text":"<p>High-performance embedded database using RocksDB.</p> <pre><code>from key_value.aio.stores.rocksdb import RocksDBStore\n\nstore = RocksDBStore(path=\"./rocksdb\")\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[rocksdb]\n</code></pre> <p>Use Cases:</p> <ul> <li>High-throughput applications</li> <li>Large datasets</li> <li>Performance-critical applications</li> </ul> <p>Characteristics:</p> <ul> <li>Very fast reads and writes</li> <li>Efficient storage</li> <li>Requires native dependencies</li> <li>Stable storage format: Unstable</li> </ul>"},{"location":"stores/#windowsregistrystore","title":"WindowsRegistryStore","text":"<p>Storage using the Windows Registry.</p> <pre><code>from key_value.aio.stores.registry import WindowsRegistryStore\n\nstore = WindowsRegistryStore(\n    hive=\"HKEY_CURRENT_USER\",\n    registry_path=\"Software\\\\py-key-value\"\n)\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[registry]\n</code></pre> <p>Use Cases:</p> <ul> <li>Windows-specific applications</li> <li>System configuration storage</li> <li>Integration with Windows settings</li> </ul> <p>Characteristics:</p> <ul> <li>Windows-only</li> <li>Persists in registry</li> <li>Subject to registry limitations</li> <li>Stable storage format: Unstable</li> </ul>"},{"location":"stores/#nullstore","title":"NullStore","text":"<p>No-op store that discards all data. Useful for testing.</p> <pre><code>from key_value.aio.stores.null import NullStore\n\nstore = NullStore()\n</code></pre> <p>Use Cases:</p> <ul> <li>Testing without side effects</li> <li>Disabling storage temporarily</li> <li>Performance baseline testing</li> </ul>"},{"location":"stores/#simplestore","title":"SimpleStore","text":"<p>Simple in-memory store for testing.</p> <pre><code>from key_value.aio.stores.simple import SimpleStore\n\nstore = SimpleStore()\n</code></pre> <p>Use Cases:</p> <ul> <li>Basic testing</li> <li>Minimal implementation reference</li> </ul>"},{"location":"stores/#secret-stores","title":"Secret Stores","text":"<p>Secret stores provide secure storage for sensitive data, typically using operating system secret management facilities.</p> Store Stability Description Keyring Stable OS-level secure storage (Keychain, Credential Manager, etc.) Vault Unstable HashiCorp Vault integration for enterprise secrets"},{"location":"stores/#keyringstore","title":"KeyringStore","text":"<p>Secure storage using the operating system's keyring (macOS Keychain, Windows Credential Manager, Linux Secret Service).</p> <pre><code>from key_value.aio.stores.keyring import KeyringStore\n\nstore = KeyringStore(service_name=\"py-key-value\")\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[keyring]\n</code></pre> <p>Use Cases:</p> <ul> <li>Storing API keys and tokens</li> <li>User credentials</li> <li>Sensitive configuration</li> <li>Encrypted local storage</li> </ul> <p>Characteristics:</p> <ul> <li>OS-level encryption</li> <li>Secure by default</li> <li>Cross-platform</li> <li>Windows limitation: Strict value length limits</li> </ul> <p>Important: Windows Keyring has strict limits on value length which may cause issues with large values.</p>"},{"location":"stores/#vaultstore","title":"VaultStore","text":"<p>Integration with HashiCorp Vault for enterprise secret management.</p> <pre><code>from key_value.aio.stores.vault import VaultStore\n\nstore = VaultStore(\n    url=\"http://localhost:8200\",\n    token=\"your-token\"\n)\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[vault]\n</code></pre> <p>Use Cases:</p> <ul> <li>Enterprise secret management</li> <li>Multi-environment deployments</li> <li>Centralized secret rotation</li> <li>Audit logging</li> </ul> <p>Characteristics:</p> <ul> <li>Enterprise-grade security</li> <li>Centralized management</li> <li>Audit logging</li> <li>Stable storage format: Unstable</li> </ul>"},{"location":"stores/#distributed-stores","title":"Distributed Stores","text":"<p>Distributed stores provide network-based storage for multi-node applications.</p> Store Stability Description Aerospike Unstable High-performance distributed NoSQL database DynamoDB Unstable AWS DynamoDB key-value storage S3 Unstable AWS S3 object storage Elasticsearch Unstable Full-text search with key-value capabilities Firestore Unstable Google Cloud Firestore key-value storage Memcached Unstable High-performance distributed memory cache MongoDB Unstable Document database used as key-value store OpenSearch Unstable OpenSearch search engine with key-value capabilities PostgreSQL Unstable PostgreSQL database with JSONB storage Redis Stable Popular in-memory data structure store Valkey Stable Open-source Redis fork"},{"location":"stores/#aerospikestore","title":"AerospikeStore","text":"<p>High-performance distributed NoSQL database optimized for speed and scale.</p> <pre><code>from key_value.aio.stores.aerospike import AerospikeStore\n\n# Using host list\nstore = AerospikeStore(\n    hosts=[(\"localhost\", 3000)],\n    namespace=\"test\",\n    set_name=\"kv-store\"\n)\n\n# Or with an existing client\nimport aerospike\nclient = aerospike.client({\"hosts\": [(\"localhost\", 3000)]})\nclient.connect()\nstore = AerospikeStore(client=client, namespace=\"test\")\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[aerospike]\n</code></pre> <p>Use Cases:</p> <ul> <li>High-throughput applications</li> <li>Real-time data processing</li> <li>Large-scale distributed systems</li> <li>Low-latency caching</li> </ul> <p>Characteristics:</p> <ul> <li>Sub-millisecond latency</li> <li>Horizontal scaling</li> <li>Native TTL support</li> <li>Namespaces must be pre-configured on server</li> <li>Sets created automatically</li> <li>Stable storage format: Unstable</li> </ul>"},{"location":"stores/#redisstore","title":"RedisStore","text":"<p>High-performance in-memory store using Redis.</p> <pre><code>from key_value.aio.stores.redis import RedisStore\n\nstore = RedisStore(url=\"redis://localhost:6379/0\")\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[redis]\n</code></pre> <p>Use Cases:</p> <ul> <li>Distributed caching</li> <li>Session storage</li> <li>Real-time applications</li> <li>High-throughput systems</li> </ul> <p>Characteristics:</p> <ul> <li>Very fast (in-memory)</li> <li>Production-ready</li> <li>Rich feature set</li> <li>Horizontal scaling support</li> <li>Stable storage format</li> </ul>"},{"location":"stores/#valkeystore","title":"ValkeyStore","text":"<p>Open-source Redis fork with similar performance characteristics.</p> <pre><code>from key_value.aio.stores.valkey import ValkeyStore\n\nstore = ValkeyStore(host=\"localhost\", port=6379)\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[valkey]\n</code></pre> <p>Use Cases:</p> <ul> <li>Same as Redis</li> <li>Open-source preference</li> <li>Redis API compatibility</li> </ul> <p>Characteristics:</p> <ul> <li>Redis-compatible</li> <li>Open-source governance</li> <li>Production-ready</li> <li>Stable storage format</li> </ul>"},{"location":"stores/#firestorestore","title":"FirestoreStore","text":"<p>Google Cloud Firestore used as a key-value store.</p> <pre><code>from key_value.aio.stores.firestore import FirestoreStore\n\nstore = FirestoreStore(credentials=google_credentials, database=\"firestore-db\")\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[firestore]\n</code></pre> <p>Use Cases:</p> <ul> <li>Google Cloud-native applications</li> <li>Serverless / managed infrastructure</li> <li>Existing Firestore deployments</li> </ul> <p>Characteristics:</p> <ul> <li>Managed cloud database</li> <li>Document/collection model</li> <li>Stable storage format: Unstable</li> </ul>"},{"location":"stores/#dynamodbstore","title":"DynamoDBStore","text":"<p>AWS DynamoDB integration for serverless and cloud-native applications.</p> <pre><code>from key_value.aio.stores.dynamodb import DynamoDBStore\n\nstore = DynamoDBStore(\n    table_name=\"kv-store\",\n    region_name=\"us-east-1\"\n)\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[dynamodb]\n</code></pre> <p>Use Cases:</p> <ul> <li>AWS-native applications</li> <li>Serverless architectures</li> <li>Global distribution</li> <li>Managed infrastructure</li> </ul> <p>Characteristics:</p> <ul> <li>Fully managed</li> <li>Auto-scaling</li> <li>Global tables</li> <li>Pay-per-use pricing</li> <li>Stable storage format: Unstable</li> </ul>"},{"location":"stores/#s3store","title":"S3Store","text":"<p>AWS S3 object storage for durable, scalable key-value storage.</p> <pre><code>from key_value.aio.stores.s3 import S3Store\n\nstore = S3Store(\n    bucket_name=\"my-kv-bucket\",\n    region_name=\"us-east-1\"\n)\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[s3]\n</code></pre> <p>Use Cases:</p> <ul> <li>Large value storage (up to 5TB per object)</li> <li>Durable, long-term storage</li> <li>Cost-effective archival</li> <li>Multi-region replication</li> </ul> <p>Characteristics:</p> <ul> <li>99.999999999% durability</li> <li>Automatic key sanitization for S3 path limits</li> <li>Supports lifecycle policies</li> <li>Pay-per-use pricing</li> <li>Stable storage format: Unstable</li> </ul>"},{"location":"stores/#elasticsearchstore","title":"ElasticsearchStore","text":"<p>Full-text search engine used as a key-value store.</p> <pre><code>from key_value.aio.stores.elasticsearch import ElasticsearchStore\n\nstore = ElasticsearchStore(\n    url=\"https://localhost:9200\",\n    api_key=\"your-api-key\",\n    index=\"kv-store\"\n)\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[elasticsearch]\n</code></pre> <p>Use Cases:</p> <ul> <li>Applications already using Elasticsearch</li> <li>Need for search capabilities</li> <li>Analytics and logging</li> </ul> <p>Characteristics:</p> <ul> <li>Search capabilities</li> <li>Distributed by default</li> <li>Rich querying</li> <li>Stable storage format: Unstable</li> </ul>"},{"location":"stores/#opensearchstore","title":"OpenSearchStore","text":"<p>OpenSearch search engine used as a key-value store. Collections are stored in separate indices with values in flattened fields.</p> <pre><code>from key_value.aio.stores.opensearch import OpenSearchStore\n\n# Using URL and API key\nstore = OpenSearchStore(\n    url=\"https://localhost:9200\",\n    api_key=\"your-api-key\",\n    index_prefix=\"kv_store\"\n)\n\n# With existing client\nfrom opensearchpy import AsyncOpenSearch\nclient = AsyncOpenSearch(hosts=[\"https://localhost:9200\"])\nstore = OpenSearchStore(\n    opensearch_client=client,\n    index_prefix=\"kv_store\"\n)\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[opensearch]\n</code></pre> <p>Use Cases:</p> <ul> <li>Applications already using OpenSearch</li> <li>Need for search capabilities with AWS-managed service</li> <li>Analytics and logging</li> </ul> <p>Characteristics:</p> <ul> <li>Search capabilities</li> <li>Distributed by default</li> <li>Collections stored in separate indices</li> <li>Values stored in flat_object fields</li> <li>Stable storage format: Unstable</li> </ul> <p>Sanitization Strategies:</p> <p>OpenSearch has specific restrictions on keys and index names. Use the built-in sanitization strategies to avoid issues:</p> <pre><code>from key_value.aio.stores.opensearch import (\n    OpenSearchStore,\n    OpenSearchV1KeySanitizationStrategy,\n    OpenSearchV1CollectionSanitizationStrategy,\n)\n\nstore = OpenSearchStore(\n    url=\"https://localhost:9200\",\n    index_prefix=\"kv_store\",\n    key_sanitization_strategy=OpenSearchV1KeySanitizationStrategy(),\n    collection_sanitization_strategy=OpenSearchV1CollectionSanitizationStrategy(),\n)\n</code></pre>"},{"location":"stores/#mongodbstore","title":"MongoDBStore","text":"<p>Document database used as a key-value store.</p> <pre><code>from key_value.aio.stores.mongodb import MongoDBStore\n\nstore = MongoDBStore(url=\"mongodb://localhost:27017/test\")\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[mongodb]\n</code></pre> <p>Use Cases:</p> <ul> <li>Applications already using MongoDB</li> <li>Document-oriented data</li> <li>Flexible schemas</li> </ul> <p>Characteristics:</p> <ul> <li>Document storage</li> <li>Rich querying</li> <li>Horizontal scaling</li> <li>Stable storage format: Unstable</li> </ul>"},{"location":"stores/#postgresqlstore","title":"PostgreSQLStore","text":"<p>PostgreSQL database with JSONB storage for flexible key-value data.</p> <p>Note: PostgreSQL is async-only. This store uses <code>asyncpg</code> which provides native async/await operations.</p> <pre><code>from key_value.aio.stores.postgresql import PostgreSQLStore\n\n# Using connection URL\nstore = PostgreSQLStore(url=\"postgresql://localhost:5432/mydb\")\n\n# Using connection parameters\nstore = PostgreSQLStore(\n    host=\"localhost\",\n    port=5432,\n    database=\"mydb\",\n    user=\"myuser\",\n    password=\"mypass\"\n)\n\nasync with store:\n    await store.put(key=\"user_1\", value={\"name\": \"Alice\"}, collection=\"users\")\n    user = await store.get(key=\"user_1\", collection=\"users\")\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[postgresql]\n</code></pre> <p>Use Cases:</p> <ul> <li>Applications already using PostgreSQL</li> <li>Need for SQL querying on stored data</li> <li>ACID transaction requirements</li> <li>Complex data relationships</li> </ul> <p>Characteristics:</p> <ul> <li>JSONB storage for efficient querying</li> <li>TTL support via expiration timestamps</li> <li>Single table design (collections as column values)</li> <li>Async-only (uses asyncpg)</li> <li>Stable storage format: Unstable</li> </ul>"},{"location":"stores/#memcachedstore","title":"MemcachedStore","text":"<p>High-performance distributed memory caching system.</p> <pre><code>from key_value.aio.stores.memcached import MemcachedStore\n\nstore = MemcachedStore(host=\"127.0.0.1\", port=11211)\n</code></pre> <p>Installation:</p> <pre><code>pip install py-key-value-aio[memcached]\n</code></pre> <p>Use Cases:</p> <ul> <li>Distributed caching</li> <li>Session storage</li> <li>High-throughput caching</li> </ul> <p>Characteristics:</p> <ul> <li>Very fast</li> <li>Simple protocol</li> <li>Distributed by design</li> <li>No persistence</li> <li>Stable storage format: Unstable</li> </ul>"},{"location":"stores/#choosing-a-store","title":"Choosing a Store","text":""},{"location":"stores/#development","title":"Development","text":"<p>Recommended: <code>MemoryStore</code> or <code>DiskStore</code></p> <ul> <li>Fast iteration</li> <li>No setup required</li> <li>Easy debugging</li> </ul> <pre><code># Development\nfrom key_value.aio.stores.memory import MemoryStore\nstore = MemoryStore()\n</code></pre>"},{"location":"stores/#production-caching","title":"Production Caching","text":"<p>Recommended: <code>RedisStore</code> or <code>ValkeyStore</code></p> <ul> <li>High performance</li> <li>Distributed</li> <li>Production-ready</li> <li>Stable storage format</li> </ul> <pre><code># Production caching\nfrom key_value.aio.stores.redis import RedisStore\nstore = RedisStore(url=\"redis://localhost:6379/0\")\n</code></pre>"},{"location":"stores/#long-term-storage","title":"Long-Term Storage","text":"<p>Recommended: Stores with Stable stability rating</p> <ul> <li><code>RedisStore</code></li> <li><code>ValkeyStore</code></li> <li><code>DiskStore</code></li> <li><code>MultiDiskStore</code></li> <li><code>KeyringStore</code></li> </ul> <p>Avoid unstable stores for data you can't afford to lose or migrate.</p>"},{"location":"stores/#sensitive-data","title":"Sensitive Data","text":"<p>Recommended: <code>KeyringStore</code> or <code>VaultStore</code></p> <ul> <li>OS-level encryption</li> <li>Secure by default</li> <li>Audit logging (Vault)</li> </ul> <pre><code># Sensitive data\nfrom key_value.aio.stores.keyring import KeyringStore\nstore = KeyringStore(service_name=\"my-app\")\n</code></pre>"},{"location":"stores/#serverlesscloud","title":"Serverless/Cloud","text":"<p>Recommended: <code>DynamoDBStore</code> (AWS)</p> <ul> <li>Fully managed</li> <li>Auto-scaling</li> <li>No servers to maintain</li> </ul> <pre><code># AWS Lambda\nfrom key_value.aio.stores.dynamodb import DynamoDBStore\nstore = DynamoDBStore(table_name=\"kv-store\", region_name=\"us-east-1\")\n</code></pre>"},{"location":"stores/#store-compatibility","title":"Store Compatibility","text":"<p>All stores implement the same protocol, making it easy to switch:</p> <pre><code># Development\nstore = MemoryStore()\n\n# Production\nstore = RedisStore(url=\"redis://localhost:6379/0\")\n\n# Your code works with both!\nawait store.put(key=\"user:123\", value={\"name\": \"Alice\"}, collection=\"users\")\n</code></pre> <p>See the API Reference for complete store documentation.</p>"},{"location":"wrappers/","title":"Wrappers","text":"<p>Wrappers are a powerful feature of py-key-value that allow you to add functionality to any key-value store. Wrappers implement the <code>AsyncKeyValue</code> protocol, so they can be used anywhere a store can be used.</p>"},{"location":"wrappers/#available-wrappers","title":"Available Wrappers","text":"Wrapper Description CompressionWrapper Compress values before storing and decompress on retrieval FernetEncryptionWrapper Encrypt values before storing and decrypt on retrieval FallbackWrapper Fallback to a secondary store when the primary store fails LimitSizeWrapper Limit the size of entries stored in the cache LoggingWrapper Log the operations performed on the store PassthroughCacheWrapper Wrap two stores to provide a read-through cache PrefixCollectionsWrapper Prefix all collections with a given prefix PrefixKeysWrapper Prefix all keys with a given prefix ReadOnlyWrapper Prevent all write operations on the underlying store RetryWrapper Retry failed operations with exponential backoff SingleCollectionWrapper Wrap a store to only use a single collection TTLClampWrapper Clamp the TTL to a given range StatisticsWrapper Track operation statistics for the store TimeoutWrapper Add timeout protection to store operations"},{"location":"wrappers/#what-are-wrappers","title":"What Are Wrappers?","text":"<p>Wrappers follow the decorator pattern - they wrap around a key-value store and intercept operations to add additional behavior. Multiple wrappers can be stacked to combine their effects.</p>"},{"location":"wrappers/#wrapper-pattern-example","title":"Wrapper Pattern Example","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.logging import LoggingWrapper\nfrom key_value.aio.wrappers.statistics import StatisticsWrapper\n\n# Stack wrappers to combine functionality\nstore = StatisticsWrapper(\n    LoggingWrapper(\n        MemoryStore()\n    )\n)\n</code></pre>"},{"location":"wrappers/#execution-order","title":"Execution Order","text":"<p>Wrappers execute in the order they are stacked:</p> <ul> <li>Writes (put, delete): Outer wrapper \u2192 Inner wrapper \u2192 Store</li> <li>Reads (get, ttl): Store \u2192 Inner wrapper \u2192 Outer wrapper</li> </ul>"},{"location":"wrappers/#wrapper-details","title":"Wrapper Details","text":""},{"location":"wrappers/#compressionwrapper","title":"CompressionWrapper","text":"<p>Compresses values before storing and decompresses on retrieval using gzip compression.</p>"},{"location":"wrappers/#key_value.aio.wrappers.compression.CompressionWrapper","title":"CompressionWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that compresses values before storing and decompresses on retrieval.</p> <p>This wrapper compresses the JSON-serialized value using the specified compression algorithm and stores it as a base64-encoded string within a special key in the dictionary. This allows compression while maintaining the dict[str, Any] interface.</p> <p>The compressed format looks like: {     \"compressed_data\": \"base64-encoded-compressed-data\",     \"compression_algorithm\": \"gzip\",     \"compression_version\": 1 }</p>"},{"location":"wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.min_size_to_compress","title":"min_size_to_compress  <code>instance-attribute</code>","text":"<pre><code>min_size_to_compress = min_size_to_compress\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, min_size_to_compress=1024)\n</code></pre> <p>Initialize the compression wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>min_size_to_compress</code> <code>int</code> <p>Only compress values larger than this many bytes.                  Defaults to 1024 bytes (1KB).</p> <code>1024</code>"},{"location":"wrappers/#key_value.aio.wrappers.compression.CompressionWrapper._compress_value","title":"_compress_value","text":"<pre><code>_compress_value(value)\n</code></pre> <p>Compress a value into the compressed format.</p>"},{"location":"wrappers/#key_value.aio.wrappers.compression.CompressionWrapper._decompress_value","title":"_decompress_value","text":"<pre><code>_decompress_value(value)\n</code></pre> <p>Decompress a value from the compressed format.</p>"},{"location":"wrappers/#key_value.aio.wrappers.compression.CompressionWrapper._should_compress","title":"_should_compress","text":"<pre><code>_should_compress(value)\n</code></pre> <p>Determine if a value should be compressed based on its size.</p>"},{"location":"wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#use-cases","title":"Use Cases","text":"<ul> <li>Storing large JSON objects</li> <li>Reducing network transfer for distributed stores</li> <li>Optimizing disk usage</li> </ul>"},{"location":"wrappers/#example","title":"Example","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.compression import CompressionWrapper\n\nstore = CompressionWrapper(\n    key_value=MemoryStore(),\n    min_size_to_compress=1024  # Only compress values &gt; 1KB\n)\n\n# Large values are automatically compressed\nawait store.put(\n    key=\"large-doc\",\n    value={\"content\": \"...\" * 1000},\n    collection=\"documents\"\n)\n</code></pre>"},{"location":"wrappers/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Compression adds CPU overhead but reduces storage/transfer size</li> <li>The <code>min_size_to_compress</code> parameter helps avoid compressing small values   where overhead exceeds benefit</li> <li>Uses gzip with compression level 1 for speed</li> </ul>"},{"location":"wrappers/#fernetencryptionwrapper","title":"FernetEncryptionWrapper","text":"<p>Encrypts values before storing and decrypts on retrieval using Fernet symmetric encryption.</p>"},{"location":"wrappers/#key_value.aio.wrappers.encryption.fernet.FernetEncryptionWrapper","title":"FernetEncryptionWrapper","text":"<p>               Bases: <code>BaseEncryptionWrapper</code></p> <p>Wrapper that encrypts values before storing and decrypts on retrieval using Fernet (symmetric encryption).</p>"},{"location":"wrappers/#key_value.aio.wrappers.encryption.fernet.FernetEncryptionWrapper.__init__","title":"__init__","text":"<pre><code>__init__(\n    key_value: AsyncKeyValue,\n    *,\n    fernet: Fernet | MultiFernet,\n    raise_on_decryption_error: bool = True,\n) -&gt; None\n</code></pre><pre><code>__init__(\n    key_value: AsyncKeyValue,\n    *,\n    source_material: str,\n    salt: str,\n    raise_on_decryption_error: bool = True,\n) -&gt; None\n</code></pre> <pre><code>__init__(\n    key_value,\n    *,\n    fernet=None,\n    source_material=None,\n    salt=None,\n    raise_on_decryption_error=True,\n)\n</code></pre>"},{"location":"wrappers/#use-cases_1","title":"Use Cases","text":"<ul> <li>Storing sensitive data (passwords, tokens, PII)</li> <li>Compliance with data protection regulations</li> <li>Encrypting data at rest</li> </ul>"},{"location":"wrappers/#example_1","title":"Example","text":"<pre><code>from cryptography.fernet import Fernet\nfrom key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.encryption.fernet import FernetEncryptionWrapper\n\n# Generate or load a key\nkey = Fernet.generate_key()\nfernet = Fernet(key)\n\nstore = FernetEncryptionWrapper(\n    key_value=MemoryStore(),\n    fernet=fernet,\n    raise_on_decryption_error=True\n)\n\n# Values are automatically encrypted\nawait store.put(\n    key=\"secret\",\n    value={\"password\": \"super-secret\"},\n    collection=\"credentials\"\n)\n</code></pre>"},{"location":"wrappers/#security-considerations","title":"Security Considerations","text":"<ul> <li>Store encryption keys securely (e.g., environment variables, key management   services)</li> <li>Use <code>MultiFernet</code> for key rotation</li> <li>Set <code>raise_on_decryption_error=True</code> to detect tampering</li> </ul>"},{"location":"wrappers/#fallbackwrapper","title":"FallbackWrapper","text":"<p>Provides failover to a secondary store if the primary store fails.</p>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper","title":"FallbackWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that falls back to a secondary store when the primary store fails.</p> <p>This wrapper attempts operations on the primary store first. If the operation fails with one of the specified exceptions, it automatically falls back to the secondary store. This provides high availability and graceful degradation when the primary store is unavailable.</p> <p>Note: This wrapper only provides read fallback by default. Writes always go to the primary store. For write fallback, consider using write_to_fallback=True, but be aware of potential consistency issues.</p>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.fallback_key_value","title":"fallback_key_value  <code>instance-attribute</code>","text":"<pre><code>fallback_key_value = fallback_key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.fallback_on","title":"fallback_on  <code>instance-attribute</code>","text":"<pre><code>fallback_on = fallback_on\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.primary_key_value","title":"primary_key_value  <code>instance-attribute</code>","text":"<pre><code>primary_key_value = primary_key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.write_to_fallback","title":"write_to_fallback  <code>instance-attribute</code>","text":"<pre><code>write_to_fallback = write_to_fallback\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.__init__","title":"__init__","text":"<pre><code>__init__(\n    primary_key_value,\n    fallback_key_value,\n    fallback_on=(Exception,),\n    write_to_fallback=False,\n)\n</code></pre> <p>Initialize the fallback wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>primary_key_value</code> <code>AsyncKeyValue</code> <p>The primary store to use.</p> required <code>fallback_key_value</code> <code>AsyncKeyValue</code> <p>The fallback store to use when primary fails.</p> required <code>fallback_on</code> <code>tuple[type[Exception], ...]</code> <p>Tuple of exception types that trigger fallback. Defaults to (Exception,).</p> <code>(Exception,)</code> <code>write_to_fallback</code> <code>bool</code> <p>If True, write operations also fall back to secondary store.                If False (default), write operations only go to primary.</p> <code>False</code>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#use-cases_2","title":"Use Cases","text":"<ul> <li>High availability setups</li> <li>Gradual migration between stores</li> <li>Local cache with remote fallback</li> </ul>"},{"location":"wrappers/#example_2","title":"Example","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.stores.redis import RedisStore\nfrom key_value.aio.wrappers.fallback import FallbackWrapper\n\nstore = FallbackWrapper(\n    primary=RedisStore(url=\"redis://localhost:6379/0\"),\n    fallback=MemoryStore()\n)\n\n# If Redis is unavailable, operations fall back to MemoryStore\nuser = await store.get(key=\"user:123\", collection=\"users\")\n</code></pre>"},{"location":"wrappers/#limitsizewrapper","title":"LimitSizeWrapper","text":"<p>Enforces size limits on stored values, raising an error if values exceed the specified size.</p>"},{"location":"wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper","title":"LimitSizeWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that limits the size of entries stored in the cache. When using a key_value store as a cache, you may want to prevent caching of very small or very large entries. This wrapper allows you to silently (or loudly) ignore entries that do not fall within the specified size limits.</p> <p>This wrapper checks the serialized size of values before storing them. This incurs a performance penalty as it requires JSON serialization of the value separate from serialization that occurs when the value is stored.</p> <p>This wrapper does not prevent returning objects (get, ttl, get_many, ttl_many) that exceed the size limit, just storing them (put, put_many).</p>"},{"location":"wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.max_size","title":"max_size  <code>instance-attribute</code>","text":"<pre><code>max_size = max_size\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.min_size","title":"min_size  <code>instance-attribute</code>","text":"<pre><code>min_size = min_size\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.raise_on_too_large","title":"raise_on_too_large  <code>instance-attribute</code>","text":"<pre><code>raise_on_too_large = raise_on_too_large\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.raise_on_too_small","title":"raise_on_too_small  <code>instance-attribute</code>","text":"<pre><code>raise_on_too_small = raise_on_too_small\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.__init__","title":"__init__","text":"<pre><code>__init__(\n    key_value,\n    *,\n    min_size=None,\n    max_size=None,\n    raise_on_too_small=False,\n    raise_on_too_large=True,\n)\n</code></pre> <p>Initialize the limit size wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>min_size</code> <code>int | None</code> <p>The minimum size (in bytes) allowed for each entry. If None, no minimum size is enforced.</p> <code>None</code> <code>max_size</code> <code>int | None</code> <p>The maximum size (in bytes) allowed for each entry. If None, no maximum size is enforced.</p> <code>None</code> <code>raise_on_too_small</code> <code>bool</code> <p>If True, raises EntryTooSmallError when an entry is less than min_size.                  If False (default), silently ignores entries that are too small.</p> <code>False</code> <code>raise_on_too_large</code> <code>bool</code> <p>If True (default), raises EntryTooLargeError when an entry exceeds max_size.                  If False, silently ignores entries that are too large.</p> <code>True</code>"},{"location":"wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper._within_size_limit","title":"_within_size_limit","text":"<pre><code>_within_size_limit(value, *, collection=None, key=None)\n</code></pre> <p>Check if a value exceeds the maximum size.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict[str, Any]</code> <p>The value to check.</p> required <code>collection</code> <code>str | None</code> <p>The collection name (for error messages).</p> <code>None</code> <code>key</code> <code>str | None</code> <p>The key name (for error messages).</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the value is within the size limit, False otherwise.</p> <p>Raises:</p> Type Description <code>EntryTooSmallError</code> <p>If raise_on_too_small is True and the value is less than min_size.</p> <code>EntryTooLargeError</code> <p>If raise_on_too_large is True and the value exceeds max_size.</p>"},{"location":"wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#use-cases_3","title":"Use Cases","text":"<ul> <li>Preventing storage of excessively large values</li> <li>Enforcing data constraints</li> <li>Protecting against abuse</li> </ul>"},{"location":"wrappers/#example_3","title":"Example","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.limit_size import LimitSizeWrapper\n\nstore = LimitSizeWrapper(\n    key_value=MemoryStore(),\n    max_size=10240  # 10KB limit\n)\n\n# Raises ValueError if value exceeds 10KB\nawait store.put(\n    key=\"doc\",\n    value={\"content\": \"...\"},\n    collection=\"documents\"\n)\n</code></pre>"},{"location":"wrappers/#loggingwrapper","title":"LoggingWrapper","text":"<p>Logs all key-value operations for debugging and auditing.</p>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper","title":"LoggingWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that logs all operations for debugging and auditing.</p> <p>This wrapper logs all key-value operations including their parameters and results. It's useful for: - Debugging application behavior - Auditing data access - Understanding cache hit/miss patterns - Monitoring performance issues</p>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.log_level","title":"log_level  <code>instance-attribute</code>","text":"<pre><code>log_level = log_level\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.log_values","title":"log_values  <code>instance-attribute</code>","text":"<pre><code>log_values = log_values\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger or getLogger('key_value.logging')\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.structured_logs","title":"structured_logs  <code>instance-attribute</code>","text":"<pre><code>structured_logs = structured_logs\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.__init__","title":"__init__","text":"<pre><code>__init__(\n    key_value,\n    logger=None,\n    log_level=INFO,\n    log_values=False,\n    structured_logs=False,\n)\n</code></pre> <p>Initialize the logging wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>logger</code> <code>Logger | None</code> <p>Logger instance to use. If None, creates a logger named 'key_value.logging'.</p> <code>None</code> <code>log_level</code> <code>int</code> <p>Logging level to use. Defaults to logging.INFO.</p> <code>INFO</code> <code>log_values</code> <code>bool</code> <p>If True, logs the actual values being stored/retrieved.        If False (default), only logs metadata (keys, collections, operation types).        Set to False to avoid logging sensitive data.</p> <code>False</code> <code>structured_logs</code> <code>bool</code> <p>If True, logs the values as structured data.        If False (default), logs the values as a string.</p> <code>False</code>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper._format_collection","title":"_format_collection","text":"<pre><code>_format_collection(collection)\n</code></pre> <p>Format collection name for logging.</p>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper._format_message","title":"_format_message","text":"<pre><code>_format_message(state, action, keys, collection, values=None, extra=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper._log","title":"_log","text":"<pre><code>_log(state, action, keys, collection, values=None, extra=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#use-cases_4","title":"Use Cases","text":"<ul> <li>Debugging store operations</li> <li>Auditing data access</li> <li>Performance monitoring</li> </ul>"},{"location":"wrappers/#example_4","title":"Example","text":"<pre><code>import logging\nfrom key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.logging import LoggingWrapper\n\nlogging.basicConfig(level=logging.INFO)\n\nstore = LoggingWrapper(\n    key_value=MemoryStore(),\n    log_level=logging.INFO\n)\n\n# All operations are logged\nawait store.put(key=\"test\", value={\"data\": \"value\"})\n# INFO: PUT key='test' collection=None ttl=None\n</code></pre>"},{"location":"wrappers/#passthroughcachewrapper","title":"PassthroughCacheWrapper","text":"<p>Provides read-through caching with a fast local cache and a slower remote store.</p>"},{"location":"wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper","title":"PassthroughCacheWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Two-tier wrapper: reads from cache store, falls back to primary and populates cache.</p> <p>TTLs from the primary are respected when writing into the cache using a clamped TTL policy.</p>"},{"location":"wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.cache_key_value","title":"cache_key_value  <code>instance-attribute</code>","text":"<pre><code>cache_key_value = TTLClampWrapper(\n    key_value=cache_key_value,\n    min_ttl=0,\n    max_ttl=maximum_ttl or DEFAULT_MAX_TTL,\n    missing_ttl=missing_ttl or DEFAULT_MISSING_TTL,\n)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.primary_key_value","title":"primary_key_value  <code>instance-attribute</code>","text":"<pre><code>primary_key_value = primary_key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.unwrapped_cache_key_value","title":"unwrapped_cache_key_value  <code>instance-attribute</code>","text":"<pre><code>unwrapped_cache_key_value = cache_key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.__init__","title":"__init__","text":"<pre><code>__init__(\n    primary_key_value, cache_key_value, maximum_ttl=None, missing_ttl=None\n)\n</code></pre> <p>Initialize the passthrough cache wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>primary_key_value</code> <code>AsyncKeyValue</code> <p>The primary store to wrap.</p> required <code>cache_key_value</code> <code>AsyncKeyValue</code> <p>The cache store to wrap.</p> required <code>maximum_ttl</code> <code>SupportsFloat | None</code> <p>The maximum TTL for puts into the cache store. Defaults to 30 minutes.</p> <code>None</code> <code>missing_ttl</code> <code>SupportsFloat | None</code> <p>The TTL to use for entries that do not have a TTL. Defaults to 30 minutes.</p> <code>None</code>"},{"location":"wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#use-cases_5","title":"Use Cases","text":"<ul> <li>Reducing latency for frequently accessed data</li> <li>Reducing load on remote stores</li> <li>Hybrid local/remote architectures</li> </ul>"},{"location":"wrappers/#example_5","title":"Example","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.stores.redis import RedisStore\nfrom key_value.aio.wrappers.passthrough_cache import PassthroughCacheWrapper\n\nstore = PassthroughCacheWrapper(\n    cache=MemoryStore(),  # Fast local cache\n    store=RedisStore(url=\"redis://localhost:6379/0\")  # Remote store\n)\n\n# First read: from Redis, cached in memory\nuser = await store.get(key=\"user:123\", collection=\"users\")\n\n# Second read: from memory cache (faster)\nuser = await store.get(key=\"user:123\", collection=\"users\")\n</code></pre>"},{"location":"wrappers/#prefixcollectionswrapper","title":"PrefixCollectionsWrapper","text":"<p>Adds a prefix to all collection names.</p>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper","title":"PrefixCollectionsWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>A wrapper that prefixes collection names before delegating to the underlying store.</p>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.default_collection","title":"default_collection  <code>instance-attribute</code>","text":"<pre><code>default_collection = default_collection or DEFAULT_COLLECTION_NAME\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.prefix","title":"prefix  <code>instance-attribute</code>","text":"<pre><code>prefix = prefix\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, prefix, default_collection=None)\n</code></pre> <p>Initialize the prefix collections wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>prefix</code> <code>str</code> <p>The prefix to add to the collections.</p> required <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided. Will be automatically prefixed with the <code>prefix</code></p> <code>None</code>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper._prefix_collection","title":"_prefix_collection","text":"<pre><code>_prefix_collection(collection)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper._unprefix_collection","title":"_unprefix_collection","text":"<pre><code>_unprefix_collection(collection)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#use-cases_6","title":"Use Cases","text":"<ul> <li>Multi-tenant applications</li> <li>Environment separation (dev/staging/prod)</li> <li>Namespace isolation</li> </ul>"},{"location":"wrappers/#example_6","title":"Example","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.prefix_collections import PrefixCollectionsWrapper\n\nstore = PrefixCollectionsWrapper(\n    key_value=MemoryStore(),\n    prefix=\"prod\"\n)\n\n# Collection becomes \"prod:users\"\nawait store.put(\n    key=\"alice\",\n    value={\"name\": \"Alice\"},\n    collection=\"users\"\n)\n</code></pre>"},{"location":"wrappers/#prefixkeyswrapper","title":"PrefixKeysWrapper","text":"<p>Adds a prefix to all keys.</p>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper","title":"PrefixKeysWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>A wrapper that prefixes key names before delegating to the underlying store.</p>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.prefix","title":"prefix  <code>instance-attribute</code>","text":"<pre><code>prefix = prefix\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, prefix)\n</code></pre> <p>Initialize the prefix keys wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>prefix</code> <code>str</code> <p>The prefix to add to the keys.</p> required"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper._prefix_key","title":"_prefix_key","text":"<pre><code>_prefix_key(key)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper._unprefix_key","title":"_unprefix_key","text":"<pre><code>_unprefix_key(key)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#use-cases_7","title":"Use Cases","text":"<ul> <li>Namespace isolation within collections</li> <li>Multi-tenant applications</li> <li>Avoiding key collisions</li> </ul>"},{"location":"wrappers/#example_7","title":"Example","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.prefix_keys import PrefixKeysWrapper\n\nstore = PrefixKeysWrapper(\n    key_value=MemoryStore(),\n    prefix=\"app1\"\n)\n\n# Key becomes \"app1:user:123\"\nawait store.put(\n    key=\"user:123\",\n    value={\"name\": \"Alice\"},\n    collection=\"users\"\n)\n</code></pre>"},{"location":"wrappers/#readonlywrapper","title":"ReadOnlyWrapper","text":"<p>Prevents all write operations, making the store read-only.</p>"},{"location":"wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper","title":"ReadOnlyWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that prevents all write operations on the underlying store.</p> <p>This wrapper allows all read operations (get, get_many, ttl, ttl_many) to pass through normally, but blocks all write operations (put, put_many, delete, delete_many). This is useful for: - Protecting production data during testing - Enforcing read-only access to read replicas - Preventing accidental modifications in certain environments</p>"},{"location":"wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.raise_on_write","title":"raise_on_write  <code>instance-attribute</code>","text":"<pre><code>raise_on_write = raise_on_write\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, raise_on_write=True)\n</code></pre> <p>Initialize the read-only wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>raise_on_write</code> <code>bool</code> <p>If True (default), raises ReadOnlyError on write attempts.            If False, silently ignores writes (put/put_many return None,            delete/delete_many return False/0).</p> <code>True</code>"},{"location":"wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#use-cases_8","title":"Use Cases","text":"<ul> <li>Shared read-only caches</li> <li>Preventing accidental writes</li> <li>Read replicas</li> </ul>"},{"location":"wrappers/#example_8","title":"Example","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.read_only import ReadOnlyWrapper\n\nstore = ReadOnlyWrapper(\n    key_value=MemoryStore()\n)\n\n# Raises ReadOnlyError\nawait store.put(key=\"test\", value={\"data\": \"value\"})\n</code></pre>"},{"location":"wrappers/#retrywrapper","title":"RetryWrapper","text":"<p>Automatically retries failed operations with exponential backoff.</p>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper","title":"RetryWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that retries failed operations with exponential backoff.</p> <p>This wrapper automatically retries operations that fail with specified exceptions, using exponential backoff between attempts. This is useful for handling transient failures like network issues or temporary service unavailability.</p>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.exponential_base","title":"exponential_base  <code>instance-attribute</code>","text":"<pre><code>exponential_base = exponential_base\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.initial_delay","title":"initial_delay  <code>instance-attribute</code>","text":"<pre><code>initial_delay = initial_delay\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.max_delay","title":"max_delay  <code>instance-attribute</code>","text":"<pre><code>max_delay = max_delay\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.max_retries","title":"max_retries  <code>instance-attribute</code>","text":"<pre><code>max_retries = max_retries\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.retry_on","title":"retry_on  <code>instance-attribute</code>","text":"<pre><code>retry_on = retry_on\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.__init__","title":"__init__","text":"<pre><code>__init__(\n    key_value,\n    max_retries=3,\n    initial_delay=0.1,\n    max_delay=10.0,\n    exponential_base=2.0,\n    retry_on=(ConnectionError, TimeoutError),\n)\n</code></pre> <p>Initialize the retry wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>max_retries</code> <code>int</code> <p>Maximum number of retry attempts. Defaults to 3.</p> <code>3</code> <code>initial_delay</code> <code>float</code> <p>Initial delay in seconds before first retry. Defaults to 0.1.</p> <code>0.1</code> <code>max_delay</code> <code>float</code> <p>Maximum delay in seconds between retries. Defaults to 10.0.</p> <code>10.0</code> <code>exponential_base</code> <code>float</code> <p>Base for exponential backoff calculation. Defaults to 2.0.</p> <code>2.0</code> <code>retry_on</code> <code>tuple[type[Exception], ...]</code> <p>Tuple of exception types to retry on. Defaults to (ConnectionError, TimeoutError).</p> <code>(ConnectionError, TimeoutError)</code>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper._calculate_delay","title":"_calculate_delay","text":"<pre><code>_calculate_delay(attempt)\n</code></pre> <p>Calculate the delay for a given attempt using exponential backoff.</p>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.retry.RetryWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#use-cases_9","title":"Use Cases","text":"<ul> <li>Handling transient network failures</li> <li>Improving reliability with remote stores</li> <li>Rate limit handling</li> </ul>"},{"location":"wrappers/#example_9","title":"Example","text":"<pre><code>from key_value.aio.stores.redis import RedisStore\nfrom key_value.aio.wrappers.retry import RetryWrapper\n\nstore = RetryWrapper(\n    key_value=RedisStore(url=\"redis://localhost:6379/0\"),\n    max_retries=3,\n    initial_delay=0.1,\n    max_delay=5.0,\n    exponential_base=2\n)\n\n# Automatically retries on failure\nuser = await store.get(key=\"user:123\", collection=\"users\")\n</code></pre>"},{"location":"wrappers/#singlecollectionwrapper","title":"SingleCollectionWrapper","text":"<p>Forces all operations to use a single collection, ignoring the collection parameter.</p>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper","title":"SingleCollectionWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>A wrapper that stores all collections within a single backing collection via key prefixing.</p>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.default_collection","title":"default_collection  <code>instance-attribute</code>","text":"<pre><code>default_collection = default_collection or DEFAULT_COLLECTION_NAME\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.separator","title":"separator  <code>instance-attribute</code>","text":"<pre><code>separator = separator or DEFAULT_PREFIX_SEPARATOR\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.single_collection","title":"single_collection  <code>instance-attribute</code>","text":"<pre><code>single_collection = single_collection\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, single_collection, default_collection=None, separator=None)\n</code></pre> <p>Initialize the prefix collections wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>single_collection</code> <code>str</code> <p>The single collection to use to store all collections.</p> required <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided.</p> <code>None</code> <code>separator</code> <code>str | None</code> <p>The separator to use for the key prefix.</p> <code>None</code>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper._prefix_key","title":"_prefix_key","text":"<pre><code>_prefix_key(key, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper._unprefix_key","title":"_unprefix_key","text":"<pre><code>_unprefix_key(key)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#use-cases_10","title":"Use Cases","text":"<ul> <li>Simplifying stores that don't need collections</li> <li>Migrating from non-collection-based stores</li> <li>Enforcing single-collection usage</li> </ul>"},{"location":"wrappers/#example_10","title":"Example","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.single_collection import SingleCollectionWrapper\n\nstore = SingleCollectionWrapper(\n    key_value=MemoryStore(),\n    collection=\"default\"\n)\n\n# All operations use \"default\" collection regardless of parameter\nawait store.put(key=\"test\", value={\"data\": \"value\"}, collection=\"ignored\")\n</code></pre>"},{"location":"wrappers/#ttlclampwrapper","title":"TTLClampWrapper","text":"<p>Clamps TTL values to a specified range, ensuring TTLs are within acceptable bounds.</p>"},{"location":"wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper","title":"TTLClampWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that enforces a maximum TTL for puts into the store.</p> <p>This wrapper only modifies write operations (put, put_many). All read operations (get, get_many, ttl, ttl_many, delete, delete_many) pass through unchanged to the underlying store.</p>"},{"location":"wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.max_ttl","title":"max_ttl  <code>instance-attribute</code>","text":"<pre><code>max_ttl = float(max_ttl)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.min_ttl","title":"min_ttl  <code>instance-attribute</code>","text":"<pre><code>min_ttl = float(min_ttl)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.missing_ttl","title":"missing_ttl  <code>instance-attribute</code>","text":"<pre><code>missing_ttl = float(missing_ttl) if missing_ttl is not None else None\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, min_ttl, max_ttl, missing_ttl=None)\n</code></pre> <p>Initialize the TTL clamp wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>min_ttl</code> <code>SupportsFloat</code> <p>The minimum TTL for puts into the store.</p> required <code>max_ttl</code> <code>SupportsFloat</code> <p>The maximum TTL for puts into the store.</p> required <code>missing_ttl</code> <code>SupportsFloat | None</code> <p>The TTL to use for entries that do not have a TTL. Defaults to None.</p> <code>None</code>"},{"location":"wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper._ttl_clamp","title":"_ttl_clamp","text":"<pre><code>_ttl_clamp(ttl: SupportsFloat) -&gt; float\n</code></pre><pre><code>_ttl_clamp(ttl: SupportsFloat | None) -&gt; float | None\n</code></pre> <pre><code>_ttl_clamp(ttl)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#use-cases_11","title":"Use Cases","text":"<ul> <li>Enforcing minimum/maximum TTLs</li> <li>Preventing excessively long or short TTLs</li> <li>Backend-specific TTL limitations</li> </ul>"},{"location":"wrappers/#example_11","title":"Example","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.ttl_clamp import TTLClampWrapper\n\nstore = TTLClampWrapper(\n    key_value=MemoryStore(),\n    min_ttl=60,      # Minimum 1 minute\n    max_ttl=86400    # Maximum 1 day\n)\n\n# TTL is clamped to range [60, 86400]\nawait store.put(\n    key=\"test\",\n    value={\"data\": \"value\"},\n    ttl=30  # Clamped to 60\n)\n</code></pre>"},{"location":"wrappers/#statisticswrapper","title":"StatisticsWrapper","text":"<p>Tracks operation statistics including counts, hits, and misses.</p>"},{"location":"wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper","title":"StatisticsWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Statistics wrapper around a KV Store that tracks operation statistics.</p> <p>Note: enumeration and destroy operations are not tracked by this wrapper.</p>"},{"location":"wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper._statistics","title":"_statistics  <code>instance-attribute</code>","text":"<pre><code>_statistics = KVStoreStatistics()\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.statistics","title":"statistics  <code>property</code>","text":"<pre><code>statistics\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#use-cases_12","title":"Use Cases","text":"<ul> <li>Performance monitoring</li> <li>Cache hit rate analysis</li> <li>Usage analytics</li> </ul>"},{"location":"wrappers/#example_12","title":"Example","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.statistics import StatisticsWrapper\n\nstore = StatisticsWrapper(\n    key_value=MemoryStore()\n)\n\n# Perform operations\nawait store.put(key=\"user:1\", value={\"name\": \"Alice\"})\nawait store.get(key=\"user:1\")  # Hit\nawait store.get(key=\"user:2\")  # Miss\n\n# Check statistics\nstats = store.get_statistics()\nprint(f\"Get operations: {stats.get.count}\")\nprint(f\"Get hits: {stats.get.hits}\")\nprint(f\"Get misses: {stats.get.misses}\")\nprint(f\"Hit rate: {stats.get.hit_rate()}\")\n\n# Reset statistics\nstore.reset_statistics()\n</code></pre>"},{"location":"wrappers/#timeoutwrapper","title":"TimeoutWrapper","text":"<p>Adds timeout constraints to all operations, raising an error if operations exceed the specified timeout.</p>"},{"location":"wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper","title":"TimeoutWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that adds timeout limits to all operations.</p> <p>This wrapper ensures that no operation takes longer than the specified timeout. If an operation exceeds the timeout, it raises asyncio.TimeoutError. This is useful for preventing operations from hanging indefinitely and for enforcing SLAs.</p>"},{"location":"wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout = timeout\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, timeout=5.0)\n</code></pre> <p>Initialize the timeout wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>timeout</code> <code>float</code> <p>Timeout in seconds for all operations. Defaults to 5.0 seconds.</p> <code>5.0</code>"},{"location":"wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"wrappers/#use-cases_13","title":"Use Cases","text":"<ul> <li>Preventing operations from hanging indefinitely</li> <li>Enforcing SLA requirements</li> <li>Circuit breaker patterns</li> </ul>"},{"location":"wrappers/#example_13","title":"Example","text":"<pre><code>from key_value.aio.stores.redis import RedisStore\nfrom key_value.aio.wrappers.timeout import TimeoutWrapper\n\nstore = TimeoutWrapper(\n    key_value=RedisStore(url=\"redis://localhost:6379/0\"),\n    timeout=1.0  # 1 second timeout\n)\n\n# Raises asyncio.TimeoutError if operation takes &gt; 1 second\nuser = await store.get(key=\"user:123\", collection=\"users\")\n</code></pre>"},{"location":"wrappers/#wrapper-stacking-guide","title":"Wrapper Stacking Guide","text":"<p>Wrappers can be stacked in any order, but some orderings are more effective than others. Here are some recommended patterns:</p>"},{"location":"wrappers/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>StatisticsWrapper(\n    LoggingWrapper(\n        TimeoutWrapper(\n            store\n        )\n    )\n)\n</code></pre>"},{"location":"wrappers/#production-ready","title":"Production Ready","text":"<pre><code>StatisticsWrapper(\n    RetryWrapper(\n        TimeoutWrapper(\n            CompressionWrapper(\n                FernetEncryptionWrapper(\n                    store\n                )\n            )\n        )\n    )\n)\n</code></pre>"},{"location":"wrappers/#development","title":"Development","text":"<pre><code>LoggingWrapper(\n    StatisticsWrapper(\n        store\n    )\n)\n</code></pre>"},{"location":"wrappers/#multi-tenant","title":"Multi-Tenant","text":"<pre><code>PrefixCollectionsWrapper(\n    PrefixKeysWrapper(\n        store\n    )\n)\n</code></pre>"},{"location":"wrappers/#creating-custom-wrappers","title":"Creating Custom Wrappers","text":"<p>To create a custom wrapper, extend <code>BaseWrapper</code> and override the methods you want to modify:</p> <pre><code>from key_value.aio.wrappers.base import BaseWrapper\nfrom typing_extensions import override\n\nclass CustomWrapper(BaseWrapper):\n    def __init__(self, key_value: AsyncKeyValue):\n        self.key_value = key_value\n        super().__init__()\n\n    @override\n    async def get(self, key: str, *, collection: str | None = None):\n        # Add custom logic before\n        print(f\"Getting key: {key}\")\n\n        # Call wrapped store\n        result = await self.key_value.get(key=key, collection=collection)\n\n        # Add custom logic after\n        print(f\"Got result: {result}\")\n\n        return result\n</code></pre> <p>See the API Reference for complete wrapper documentation.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete API reference documentation for py-key-value.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>The py-key-value API is organized into four main components:</p> <ul> <li>Protocols - Core interfaces for the key-value store</li> <li>Stores - Backend implementations for different storage systems</li> <li>Wrappers - Decorators that add functionality to stores</li> <li>Adapters - Utilities that simplify working with stores</li> </ul>"},{"location":"api/#quick-links","title":"Quick Links","text":""},{"location":"api/#core-protocols","title":"Core Protocols","text":"<p>The <code>AsyncKeyValue</code> protocol defines the interface that all stores implement.</p>"},{"location":"api/#popular-stores","title":"Popular Stores","text":"<ul> <li>MemoryStore - In-memory storage</li> <li>RedisStore - Redis backend</li> <li>DiskStore - File-based storage</li> </ul>"},{"location":"api/#common-wrappers","title":"Common Wrappers","text":"<ul> <li>LoggingWrapper - Add logging to any store</li> <li>CacheWrapper - Add caching layer</li> <li>RetryWrapper - Add automatic retry logic</li> </ul>"},{"location":"api/#using-the-api-reference","title":"Using the API Reference","text":"<p>Each page provides:</p> <ul> <li>Type signatures - Full type information for all parameters and return values</li> <li>Docstrings - Detailed descriptions of functionality</li> <li>Source links - View the implementation on GitHub</li> <li>Cross-references - Navigate between related components</li> </ul>"},{"location":"api/#example-usage","title":"Example Usage","text":"<pre><code>from key_value.aio.stores.memory import MemoryStore\nfrom key_value.aio.wrappers.logging import LoggingWrapper\n\n# Create a store with logging\nstore = LoggingWrapper(MemoryStore())\n\n# Use the store\nawait store.put(\"key\", \"value\")\nresult = await store.get(\"key\")\n</code></pre> <p>For more examples and guides, see the User Guide.</p>"},{"location":"api/adapters/","title":"Adapters API Reference","text":"<p>Complete API reference for all available adapters.</p>"},{"location":"api/adapters/#pydanticadapter","title":"PydanticAdapter","text":""},{"location":"api/adapters/#key_value.aio.adapters.pydantic.PydanticAdapter","title":"PydanticAdapter","text":"<p>               Bases: <code>BasePydanticAdapter[T]</code></p> <p>Adapter for persisting any pydantic-serializable type.</p> <p>This is the \"less safe\" adapter that accepts any Python type that Pydantic can serialize. Unlike BaseModelAdapter (which is constrained to BaseModel types), this adapter can handle: - Pydantic BaseModel instances - Dataclasses (standard and Pydantic) - TypedDict - Primitive types (int, str, float, bool, etc.) - Collection types (list, dict, set, tuple, etc.) - Datetime and other common types</p> <p>Types that serialize to dicts (BaseModel, dataclass, TypedDict, dict) are stored directly. Other types are wrapped in {\"items\": value} to ensure consistent dict-based storage.</p>"},{"location":"api/adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._default_collection","title":"_default_collection  <code>instance-attribute</code>","text":"<pre><code>_default_collection = default_collection\n</code></pre>"},{"location":"api/adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._key_value","title":"_key_value  <code>instance-attribute</code>","text":"<pre><code>_key_value = key_value\n</code></pre>"},{"location":"api/adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._needs_wrapping","title":"_needs_wrapping  <code>instance-attribute</code>","text":"<pre><code>_needs_wrapping = _check_needs_wrapping()\n</code></pre>"},{"location":"api/adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._raise_on_validation_error","title":"_raise_on_validation_error  <code>instance-attribute</code>","text":"<pre><code>_raise_on_validation_error = raise_on_validation_error\n</code></pre>"},{"location":"api/adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._type_adapter","title":"_type_adapter  <code>instance-attribute</code>","text":"<pre><code>_type_adapter = TypeAdapter[T](pydantic_model)\n</code></pre>"},{"location":"api/adapters/#key_value.aio.adapters.pydantic.PydanticAdapter.__init__","title":"__init__","text":"<pre><code>__init__(\n    key_value,\n    pydantic_model,\n    default_collection=None,\n    raise_on_validation_error=False,\n)\n</code></pre> <p>Create a new PydanticAdapter.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The KVStore to use.</p> required <code>pydantic_model</code> <code>TypeForm[T]</code> <p>The type to serialize/deserialize. Can be any pydantic-serializable type.</p> required <code>default_collection</code> <code>str | None</code> <p>The default collection to use.</p> <code>None</code> <code>raise_on_validation_error</code> <code>bool</code> <p>Whether to raise a DeserializationError if validation fails during reads.                        Otherwise, calls will return None if validation fails.</p> <code>False</code>"},{"location":"api/adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._check_needs_wrapping","title":"_check_needs_wrapping","text":"<pre><code>_check_needs_wrapping()\n</code></pre> <p>Check if a type needs to be wrapped in {\"items\": ...} for storage.</p> <p>Types that serialize to dicts don't need wrapping. Other types do.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the type needs wrapping, False otherwise.</p>"},{"location":"api/adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._get_model_type_name","title":"_get_model_type_name","text":"<pre><code>_get_model_type_name()\n</code></pre> <p>Return the model type name for error messages.</p>"},{"location":"api/adapters/#key_value.aio.adapters.pydantic.PydanticAdapter._serializes_to_dict","title":"_serializes_to_dict","text":"<pre><code>_serializes_to_dict()\n</code></pre> <p>Check if a type serializes to a dict by inspecting the TypeAdapter's JSON schema.</p> <p>This uses Pydantic's TypeAdapter.json_schema() to reliably determine the output structure. Types that produce a JSON object (schema type \"object\") are dict-serializable.</p> <p>Uses a custom schema generator to skip fields that can't be represented in JSON schema (e.g., Callable fields), avoiding PydanticInvalidForJsonSchema errors.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the type serializes to a dict (JSON object), False otherwise.</p>"},{"location":"api/adapters/#raiseonmissingadapter","title":"RaiseOnMissingAdapter","text":""},{"location":"api/adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter","title":"RaiseOnMissingAdapter","text":"<p>Adapter around a KVStore that raises on missing values for get/get_many/ttl/ttl_many.</p> <p>When <code>raise_on_missing=True</code>, methods raise <code>MissingKeyError</code> instead of returning None.</p>"},{"location":"api/adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"api/adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.__init__","title":"__init__","text":"<pre><code>__init__(key_value)\n</code></pre>"},{"location":"api/adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre> <p>Delete a key-value pair from the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to delete the value from.</p> required <code>collection</code> <code>str | None</code> <p>The collection to delete the value from. If no collection is provided, it will use the default collection.</p> <code>None</code>"},{"location":"api/adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre> <p>Delete multiple key-value pairs from the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Sequence[str]</code> <p>The keys to delete the values from.</p> required <code>collection</code> <code>str | None</code> <p>The collection to delete keys from. If no collection is provided, it will use the default collection.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of keys deleted.</p>"},{"location":"api/adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.get","title":"get  <code>async</code>","text":"<pre><code>get(\n    key: str,\n    *,\n    collection: str | None = None,\n    raise_on_missing: Literal[False] = False,\n) -&gt; dict[str, Any] | None\n</code></pre><pre><code>get(\n    key: str, *, collection: str | None = None, raise_on_missing: Literal[True]\n) -&gt; dict[str, Any]\n</code></pre> <pre><code>get(key, *, collection=None, raise_on_missing=False)\n</code></pre> <p>Retrieve a value by key from the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve the value from.</p> required <code>collection</code> <code>str | None</code> <p>The collection to retrieve the value from. If no collection is provided, it will use the default collection.</p> <code>None</code> <code>raise_on_missing</code> <code>bool</code> <p>Whether to raise a MissingKeyError if the key is not found.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>The value associated with the key. If the key is not found, None will be returned.</p>"},{"location":"api/adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(\n    keys: Sequence[str],\n    *,\n    collection: str | None = None,\n    raise_on_missing: Literal[False] = False,\n) -&gt; list[dict[str, Any] | None]\n</code></pre><pre><code>get_many(\n    keys: Sequence[str],\n    *,\n    collection: str | None = None,\n    raise_on_missing: Literal[True],\n) -&gt; list[dict[str, Any]]\n</code></pre> <pre><code>get_many(keys, *, collection=None, raise_on_missing=False)\n</code></pre> <p>Retrieve multiple values by key from the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Sequence[str]</code> <p>The keys to retrieve the values from.</p> required <code>collection</code> <code>str | None</code> <p>The collection to retrieve keys from. If no collection is provided, it will use the default collection.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]] | list[dict[str, Any] | None]</code> <p>The values for the keys, or [] if the key is not found.</p>"},{"location":"api/adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre> <p>Store a key-value pair in the specified collection with optional TTL.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to store the value in.</p> required <code>value</code> <code>Mapping[str, Any]</code> <p>The value to store.</p> required <code>collection</code> <code>str | None</code> <p>The collection to store the value in. If no collection is provided, it will use the default collection.</p> <code>None</code> <code>ttl</code> <code>SupportsFloat | None</code> <p>The optional time-to-live (expiry duration) for the key-value pair. Defaults to no TTL. Note: The backend store will convert the provided format to its own internal format.</p> <code>None</code>"},{"location":"api/adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre> <p>Store multiple key-value pairs in the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Sequence[str]</code> <p>The keys to store the values in.</p> required <code>values</code> <code>Sequence[Mapping[str, Any]]</code> <p>The values to store.</p> required <code>collection</code> <code>str | None</code> <p>The collection to store keys in. If no collection is provided, it will use the default collection.</p> <code>None</code> <code>ttl</code> <code>SupportsFloat | None</code> <p>The optional time-to-live (expiry duration) for all key-value pairs. The same TTL will be applied to all items in the batch. Defaults to no TTL. Note: The backend store will convert the provided format to its own internal format.</p> <code>None</code>"},{"location":"api/adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(\n    key: str,\n    *,\n    collection: str | None = None,\n    raise_on_missing: Literal[False] = False,\n) -&gt; tuple[dict[str, Any] | None, float | None]\n</code></pre><pre><code>ttl(\n    key: str, *, collection: str | None = None, raise_on_missing: Literal[True]\n) -&gt; tuple[dict[str, Any], float | None]\n</code></pre> <pre><code>ttl(key, *, collection=None, raise_on_missing=False)\n</code></pre> <p>Retrieve the value and TTL information for a key-value pair from the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve the TTL information from.</p> required <code>collection</code> <code>str | None</code> <p>The collection to retrieve the TTL information from. If no collection is provided,         it will use the default collection.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[dict[str, Any] | None, float | None]</code> <p>The value and TTL information for the key. If the key is not found, (None, None) will be returned.</p>"},{"location":"api/adapters/#key_value.aio.adapters.raise_on_missing.RaiseOnMissingAdapter.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(\n    keys: Sequence[str],\n    *,\n    collection: str | None = None,\n    raise_on_missing: Literal[False] = False,\n) -&gt; list[tuple[dict[str, Any] | None, float | None]]\n</code></pre><pre><code>ttl_many(\n    keys: Sequence[str],\n    *,\n    collection: str | None = None,\n    raise_on_missing: Literal[True],\n) -&gt; list[tuple[dict[str, Any], float | None]]\n</code></pre> <pre><code>ttl_many(keys, *, collection=None, raise_on_missing=False)\n</code></pre> <p>Retrieve multiple values and TTL information by key from the specified collection.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Sequence[str]</code> <p>The keys to retrieve the values and TTL information from.</p> required <code>collection</code> <code>str | None</code> <p>The collection to retrieve keys from. If no collection is provided, it will use the default collection.</p> <code>None</code>"},{"location":"api/protocols/","title":"Protocols","text":"<p>The <code>AsyncKeyValue</code> protocol defines the interface that all stores and wrappers must implement. This protocol-based design allows for maximum flexibility and composability.</p>"},{"location":"api/protocols/#asynckeyvalue-protocol","title":"AsyncKeyValue Protocol","text":""},{"location":"api/protocols/#key_value.aio.protocols.key_value.AsyncKeyValue","title":"AsyncKeyValue","text":"<p>               Bases: <code>AsyncKeyValueProtocol</code>, <code>Protocol</code></p> <p>A protocol for key-value store operations.</p> <p>Includes basic operations: get, put, delete, ttl Includes bulk operations: get_many, put_many, delete_many, ttl_many.</p> Source code in <code>src/key_value/aio/protocols/key_value.py</code> <pre><code>class AsyncKeyValue(AsyncKeyValueProtocol, Protocol):\n    \"\"\"A protocol for key-value store operations.\n\n    Includes basic operations: get, put, delete, ttl\n    Includes bulk operations: get_many, put_many, delete_many, ttl_many.\n    \"\"\"\n</code></pre>"},{"location":"api/stores/","title":"Stores","text":"<p>Stores are implementations of the <code>AsyncKeyValue</code> protocol that provide actual storage backends.</p>"},{"location":"api/stores/#memory-store","title":"Memory Store","text":"<p>In-memory key-value store, useful for testing and development.</p>"},{"location":"api/stores/#key_value.aio.stores.memory.MemoryStore","title":"MemoryStore","text":"<p>               Bases: <code>BaseDestroyStore</code>, <code>BaseDestroyCollectionStore</code>, <code>BaseEnumerateCollectionsStore</code>, <code>BaseEnumerateKeysStore</code></p> <p>A fixed-size in-memory key-value store using TLRU (Time-aware Least Recently Used) cache.</p>"},{"location":"api/stores/#key_value.aio.stores.memory.MemoryStore.__init__","title":"__init__","text":"<pre><code>__init__(\n    *, max_entries_per_collection=None, default_collection=None, seed=None\n)\n</code></pre> <p>Initialize a fixed-size in-memory store.</p> <p>Parameters:</p> Name Type Description Default <code>max_entries_per_collection</code> <code>int | None</code> <p>The maximum number of entries per collection. Defaults to no limit.</p> <code>None</code> <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided.</p> <code>None</code> <code>seed</code> <code>SEED_DATA_TYPE | None</code> <p>Optional seed data to pre-populate the store. Format: {collection: {key: {field: value, ...}}}. Each value must be a mapping (dict) that will be stored as the entry's value. Seeding occurs lazily when each collection is first accessed.</p> <code>None</code>"},{"location":"api/stores/#disk-store","title":"Disk Store","text":"<p>Persistent disk-based key-value store using DiskCache.</p>"},{"location":"api/stores/#key_value.aio.stores.disk.DiskStore","title":"DiskStore","text":"<p>               Bases: <code>BaseContextManagerStore</code>, <code>BaseStore</code></p> <p>A disk-based store that uses the diskcache library to store data.</p>"},{"location":"api/stores/#key_value.aio.stores.disk.DiskStore.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    disk_cache: Cache,\n    default_collection: str | None = None,\n    auto_create: bool = True,\n) -&gt; None\n</code></pre><pre><code>__init__(\n    *,\n    directory: Path | str,\n    max_size: int | None = None,\n    default_collection: str | None = None,\n    auto_create: bool = True,\n) -&gt; None\n</code></pre> <pre><code>__init__(\n    *,\n    disk_cache=None,\n    directory=None,\n    max_size=None,\n    default_collection=None,\n    auto_create=True,\n)\n</code></pre> <p>Initialize the disk store.</p> <p>Parameters:</p> Name Type Description Default <code>disk_cache</code> <code>Cache | None</code> <p>An existing diskcache Cache instance to use. If provided, the store will not manage the cache's lifecycle (will not close it). The caller is responsible for managing the cache's lifecycle.</p> <code>None</code> <code>directory</code> <code>Path | str | None</code> <p>The directory to use for the disk store.</p> <code>None</code> <code>max_size</code> <code>int | None</code> <p>The maximum size of the disk store.</p> <code>None</code> <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided.</p> <code>None</code> <code>auto_create</code> <code>bool</code> <p>Whether to automatically create the directory if it doesn't exist. Defaults to True. When False, raises ValueError if the directory doesn't exist.</p> <code>True</code>"},{"location":"api/stores/#filetree-store","title":"FileTree Store","text":"<p>Directory-based store for visual inspection and testing.</p>"},{"location":"api/stores/#key_value.aio.stores.filetree.FileTreeStore","title":"FileTreeStore","text":"<p>               Bases: <code>BaseStore</code></p> <p>A file-tree based store using directories for collections and files for keys.</p> <p>This store uses the native filesystem: - Each collection is a subdirectory under the base directory - Each key is stored as a JSON file named \"{key}.json\" - File contents contain the ManagedEntry serialized to JSON</p> Directory structure <p>{base_directory}/     {collection_1}/         {key_1}.json         {key_2}.json     {collection_2}/         {key_3}.json</p> <p>By default, collections and keys are not sanitized. This means that filesystem limitations on path lengths and special characters may cause errors when trying to get and put entries.</p> <p>To avoid issues, you may want to consider leveraging the <code>FileTreeV1CollectionSanitizationStrategy</code> and <code>FileTreeV1KeySanitizationStrategy</code> strategies.</p> Security <p>This store includes the following security measures: - Path validation: All file paths are validated to stay within the data directory.   The validation uses <code>resolve()</code> which follows symlinks, so symlink-based escapes   are also detected and blocked. - Atomic writes: Files are written atomically using write-to-temp-then-rename with   fsync for durability. This ensures data is not corrupted on system crash.</p> Limitations <ul> <li>No file locking: Concurrent writes to the same key from multiple processes may   cause data loss (last write wins). Single-writer or external locking is recommended   for multi-process scenarios.</li> <li>No built-in cleanup of expired entries. Expired entries are only filtered out when   read via get() or similar methods.</li> <li>Performance may degrade with very large numbers of keys per collection due to   filesystem directory entry limits.</li> </ul>"},{"location":"api/stores/#key_value.aio.stores.filetree.FileTreeStore.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    data_directory,\n    metadata_directory=None,\n    default_collection=None,\n    serialization_adapter=None,\n    key_sanitization_strategy=None,\n    collection_sanitization_strategy=None,\n    auto_create=True,\n)\n</code></pre> <p>Initialize the file-tree store.</p> <p>Parameters:</p> Name Type Description Default <code>data_directory</code> <code>Path | str</code> <p>The base directory to use for storing collections and keys.</p> required <code>metadata_directory</code> <code>Path | str | None</code> <p>The directory to use for storing metadata. Defaults to data_directory.</p> <code>None</code> <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided.</p> <code>None</code> <code>serialization_adapter</code> <code>SerializationAdapter | None</code> <p>The serialization adapter to use for the store.</p> <code>None</code> <code>key_sanitization_strategy</code> <code>SanitizationStrategy | None</code> <p>The sanitization strategy to use for keys.</p> <code>None</code> <code>collection_sanitization_strategy</code> <code>SanitizationStrategy | None</code> <p>The sanitization strategy to use for collections.</p> <code>None</code> <code>auto_create</code> <code>bool</code> <p>Whether to automatically create directories if they don't exist. Defaults to True. When False, raises ValueError if a directory doesn't exist.</p> <code>True</code>"},{"location":"api/stores/#redis-store","title":"Redis Store","text":"<p>Redis-backed key-value store.</p>"},{"location":"api/stores/#key_value.aio.stores.redis.RedisStore","title":"RedisStore","text":"<p>               Bases: <code>BaseDestroyStore</code>, <code>BaseEnumerateKeysStore</code>, <code>BaseContextManagerStore</code>, <code>BaseStore</code></p> <p>Redis-based key-value store.</p>"},{"location":"api/stores/#key_value.aio.stores.redis.RedisStore.__init__","title":"__init__","text":"<pre><code>__init__(*, client: Redis, default_collection: str | None = None) -&gt; None\n</code></pre><pre><code>__init__(*, url: str, default_collection: str | None = None) -&gt; None\n</code></pre><pre><code>__init__(\n    *,\n    host: str = \"localhost\",\n    port: int = 6379,\n    db: int = 0,\n    password: str | None = None,\n    default_collection: str | None = None,\n) -&gt; None\n</code></pre> <pre><code>__init__(\n    *,\n    client=None,\n    default_collection=None,\n    url=None,\n    host=\"localhost\",\n    port=6379,\n    db=0,\n    password=None,\n)\n</code></pre> <p>Initialize the Redis store.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Redis | None</code> <p>An existing Redis client to use. If provided, the store will not manage the client's lifecycle (will not close it). The caller is responsible for managing the client's lifecycle.</p> <code>None</code> <code>url</code> <code>str | None</code> <p>Redis URL (e.g., redis://localhost:6379/0).</p> <code>None</code> <code>host</code> <code>str</code> <p>Redis host. Defaults to localhost.</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Redis port. Defaults to 6379.</p> <code>6379</code> <code>db</code> <code>int</code> <p>Redis database number. Defaults to 0.</p> <code>0</code> <code>password</code> <code>str | None</code> <p>Redis password. Defaults to None.</p> <code>None</code> <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided.</p> <code>None</code>"},{"location":"api/stores/#dynamodb-store","title":"DynamoDB Store","text":"<p>AWS DynamoDB-backed key-value store.</p>"},{"location":"api/stores/#key_value.aio.stores.dynamodb.DynamoDBStore","title":"DynamoDBStore","text":"<p>               Bases: <code>BaseContextManagerStore</code>, <code>BaseStore</code></p> <p>DynamoDB-based key-value store.</p> <p>This store uses a single DynamoDB table with a composite primary key: - collection (partition key) - key (sort key)</p>"},{"location":"api/stores/#key_value.aio.stores.dynamodb.DynamoDBStore.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    client: AioBaseClient,\n    table_name: str,\n    default_collection: str | None = None,\n    table_config: dict[str, Any] | None = None,\n    auto_create: bool = True,\n) -&gt; None\n</code></pre><pre><code>__init__(\n    *,\n    table_name: str,\n    region_name: str | None = None,\n    endpoint_url: str | None = None,\n    aws_access_key_id: str | None = None,\n    aws_secret_access_key: str | None = None,\n    aws_session_token: str | None = None,\n    default_collection: str | None = None,\n    table_config: dict[str, Any] | None = None,\n    auto_create: bool = True,\n) -&gt; None\n</code></pre> <pre><code>__init__(\n    *,\n    client=None,\n    table_name,\n    region_name=None,\n    endpoint_url=None,\n    aws_access_key_id=None,\n    aws_secret_access_key=None,\n    aws_session_token=None,\n    default_collection=None,\n    table_config=None,\n    auto_create=True,\n)\n</code></pre> <p>Initialize the DynamoDB store.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>AioBaseClient | None</code> <p>The DynamoDB client to use. If provided, the store will not manage the client's lifecycle (will not enter/exit its context manager). The caller is responsible for managing the client's lifecycle and must ensure the client is already entered.</p> <code>None</code> <code>table_name</code> <code>str</code> <p>The name of the DynamoDB table to use.</p> required <code>region_name</code> <code>str | None</code> <p>AWS region name. Defaults to None (uses AWS default).</p> <code>None</code> <code>endpoint_url</code> <code>str | None</code> <p>Custom endpoint URL (useful for local DynamoDB). Defaults to None.</p> <code>None</code> <code>aws_access_key_id</code> <code>str | None</code> <p>AWS access key ID. Defaults to None (uses AWS default credentials).</p> <code>None</code> <code>aws_secret_access_key</code> <code>str | None</code> <p>AWS secret access key. Defaults to None (uses AWS default credentials).</p> <code>None</code> <code>aws_session_token</code> <code>str | None</code> <p>AWS session token. Defaults to None (uses AWS default credentials).</p> <code>None</code> <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided.</p> <code>None</code> <code>table_config</code> <code>dict[str, Any] | None</code> <p>Additional configuration to pass to create_table(). Merged with defaults. Examples: SSESpecification, Tags, StreamSpecification, etc. Note: Critical parameters (TableName, KeySchema, AttributeDefinitions, BillingMode) cannot be overridden as they are required for store operation.</p> <code>None</code> <code>auto_create</code> <code>bool</code> <p>Whether to automatically create the table if it doesn't exist. Defaults to True. When False, raises ValueError if the table doesn't exist.</p> <code>True</code>"},{"location":"api/stores/#s3-store","title":"S3 Store","text":"<p>AWS S3-backed key-value store.</p>"},{"location":"api/stores/#key_value.aio.stores.s3.S3Store","title":"S3Store","text":"<p>               Bases: <code>BaseContextManagerStore</code>, <code>BaseStore</code></p> <p>AWS S3-based key-value store.</p> <p>This store uses AWS S3 to store key-value pairs as objects. Each entry is stored as a separate S3 object with the path format: {collection}/{key}. The ManagedEntry is serialized to JSON and stored as the object body. TTL information is stored in S3 object metadata and checked client-side during retrieval (S3 lifecycle policies can be configured separately for background cleanup, but don't provide atomic TTL+retrieval).</p> <p>By default, collections and keys are not sanitized. This means you must ensure that the combined \"{collection}/{key}\" path does not exceed S3's 1024-byte limit when UTF-8 encoded.</p> <p>To handle long collection or key names, use the S3CollectionSanitizationStrategy and S3KeySanitizationStrategy which will hash values exceeding the byte limit.</p> Example <p>Basic usage with automatic AWS credentials:</p> <p>async with S3Store(bucket_name=\"my-kv-store\") as store: ...     await store.put(key=\"user:123\", value={\"name\": \"Alice\"}, ttl=3600) ...     user = await store.get(key=\"user:123\")</p> <p>With sanitization for long keys/collections:</p> <p>async with S3Store( ...     bucket_name=\"my-kv-store\", ...     collection_sanitization_strategy=S3CollectionSanitizationStrategy(), ...     key_sanitization_strategy=S3KeySanitizationStrategy(), ... ) as store: ...     await store.put(key=\"very_long_key\" * 100, value={\"data\": \"test\"})</p> <p>With custom AWS credentials:</p> <p>async with S3Store( ...     bucket_name=\"my-kv-store\", ...     region_name=\"us-west-2\", ...     aws_access_key_id=\"...\", ...     aws_secret_access_key=\"...\", ... ) as store: ...     await store.put(key=\"config\", value={\"setting\": \"value\"})</p> <p>For local testing with LocalStack:</p> <p>async with S3Store( ...     bucket_name=\"test-bucket\", ...     endpoint_url=\"http://localhost:4566\", ... ) as store: ...     await store.put(key=\"test\", value={\"data\": \"test\"})</p>"},{"location":"api/stores/#key_value.aio.stores.s3.S3Store.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    client: AioBaseClient,\n    bucket_name: str,\n    default_collection: str | None = None,\n    collection_sanitization_strategy: SanitizationStrategy | None = None,\n    key_sanitization_strategy: SanitizationStrategy | None = None,\n) -&gt; None\n</code></pre><pre><code>__init__(\n    *,\n    bucket_name: str,\n    region_name: str | None = None,\n    endpoint_url: str | None = None,\n    aws_access_key_id: str | None = None,\n    aws_secret_access_key: str | None = None,\n    aws_session_token: str | None = None,\n    default_collection: str | None = None,\n    collection_sanitization_strategy: SanitizationStrategy | None = None,\n    key_sanitization_strategy: SanitizationStrategy | None = None,\n) -&gt; None\n</code></pre> <pre><code>__init__(\n    *,\n    client=None,\n    bucket_name,\n    region_name=None,\n    endpoint_url=None,\n    aws_access_key_id=None,\n    aws_secret_access_key=None,\n    aws_session_token=None,\n    default_collection=None,\n    collection_sanitization_strategy=None,\n    key_sanitization_strategy=None,\n)\n</code></pre> <p>Initialize the S3 store.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>AioBaseClient | None</code> <p>The S3 client to use. Defaults to None (creates a new client).</p> <code>None</code> <code>bucket_name</code> <code>str</code> <p>The name of the S3 bucket to use.</p> required <code>region_name</code> <code>str | None</code> <p>AWS region name. Defaults to None (uses AWS default).</p> <code>None</code> <code>endpoint_url</code> <code>str | None</code> <p>Custom endpoint URL (useful for LocalStack/MinIO). Defaults to None.</p> <code>None</code> <code>aws_access_key_id</code> <code>str | None</code> <p>AWS access key ID. Defaults to None (uses AWS default credentials).</p> <code>None</code> <code>aws_secret_access_key</code> <code>str | None</code> <p>AWS secret access key. Defaults to None (uses AWS default credentials).</p> <code>None</code> <code>aws_session_token</code> <code>str | None</code> <p>AWS session token. Defaults to None (uses AWS default credentials).</p> <code>None</code> <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided.</p> <code>None</code> <code>collection_sanitization_strategy</code> <code>SanitizationStrategy | None</code> <p>Strategy for sanitizing collection names. Defaults to None (no sanitization).</p> <code>None</code> <code>key_sanitization_strategy</code> <code>SanitizationStrategy | None</code> <p>Strategy for sanitizing keys. Defaults to None (no sanitization).</p> <code>None</code>"},{"location":"api/stores/#elasticsearch-store","title":"Elasticsearch Store","text":"<p>Elasticsearch-backed key-value store.</p>"},{"location":"api/stores/#key_value.aio.stores.elasticsearch.ElasticsearchStore","title":"ElasticsearchStore","text":"<p>               Bases: <code>BaseEnumerateCollectionsStore</code>, <code>BaseEnumerateKeysStore</code>, <code>BaseDestroyCollectionStore</code>, <code>BaseCullStore</code>, <code>BaseContextManagerStore</code>, <code>BaseStore</code></p> <p>An Elasticsearch-based store.</p> <p>Stores collections in their own indices and stores values in Flattened fields.</p> <p>This store has specific restrictions on what is allowed in keys and collections. Keys and collections are not sanitized by default which may result in errors when using the store.</p> <p>To avoid issues, you may want to consider leveraging the <code>ElasticsearchV1KeySanitizationStrategy</code> and <code>ElasticsearchV1CollectionSanitizationStrategy</code> strategies.</p>"},{"location":"api/stores/#key_value.aio.stores.elasticsearch.ElasticsearchStore.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    elasticsearch_client: AsyncElasticsearch,\n    index_prefix: str,\n    default_collection: str | None = None,\n    key_sanitization_strategy: SanitizationStrategy | None = None,\n    collection_sanitization_strategy: SanitizationStrategy | None = None,\n    auto_create: bool = True,\n) -&gt; None\n</code></pre><pre><code>__init__(\n    *,\n    url: str,\n    api_key: str | None = None,\n    index_prefix: str,\n    default_collection: str | None = None,\n    key_sanitization_strategy: SanitizationStrategy | None = None,\n    collection_sanitization_strategy: SanitizationStrategy | None = None,\n    auto_create: bool = True,\n) -&gt; None\n</code></pre> <pre><code>__init__(\n    *,\n    elasticsearch_client=None,\n    url=None,\n    api_key=None,\n    index_prefix,\n    default_collection=None,\n    key_sanitization_strategy=None,\n    collection_sanitization_strategy=None,\n    auto_create=True,\n)\n</code></pre> <p>Initialize the elasticsearch store.</p> <p>Parameters:</p> Name Type Description Default <code>elasticsearch_client</code> <code>AsyncElasticsearch | None</code> <p>The elasticsearch client to use. If provided, the store will not manage the client's lifecycle (will not close it). The caller is responsible for managing the client's lifecycle.</p> <code>None</code> <code>url</code> <code>str | None</code> <p>The url of the elasticsearch cluster.</p> <code>None</code> <code>api_key</code> <code>str | None</code> <p>The api key to use.</p> <code>None</code> <code>index_prefix</code> <code>str</code> <p>The index prefix to use. Collections will be prefixed with this prefix.</p> required <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided.</p> <code>None</code> <code>key_sanitization_strategy</code> <code>SanitizationStrategy | None</code> <p>The sanitization strategy to use for keys.</p> <code>None</code> <code>collection_sanitization_strategy</code> <code>SanitizationStrategy | None</code> <p>The sanitization strategy to use for collections.</p> <code>None</code> <code>auto_create</code> <code>bool</code> <p>Whether to automatically create indices if they don't exist. Defaults to True. When False, raises ValueError if an index doesn't exist.</p> <code>True</code>"},{"location":"api/stores/#mongodb-store","title":"MongoDB Store","text":"<p>MongoDB-backed key-value store.</p>"},{"location":"api/stores/#key_value.aio.stores.mongodb.MongoDBStore","title":"MongoDBStore","text":"<p>               Bases: <code>BaseDestroyCollectionStore</code>, <code>BaseContextManagerStore</code>, <code>BaseStore</code></p> <p>MongoDB-based key-value store using pymongo.</p> <p>Stores collections as MongoDB collections and stores values in document fields.</p> <p>By default, collections are not sanitized. This means that there are character and length restrictions on collection names that may cause errors when trying to get and put entries.</p> <p>To avoid issues, you may want to consider leveraging the <code>MongoDBV1CollectionSanitizationStrategy</code> strategy.</p>"},{"location":"api/stores/#key_value.aio.stores.mongodb.MongoDBStore.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    client: AsyncMongoClient[dict[str, Any]],\n    db_name: str | None = None,\n    coll_name: str | None = None,\n    default_collection: str | None = None,\n    collection_sanitization_strategy: SanitizationStrategy | None = None,\n    auto_create: bool = True,\n) -&gt; None\n</code></pre><pre><code>__init__(\n    *,\n    url: str,\n    db_name: str | None = None,\n    coll_name: str | None = None,\n    default_collection: str | None = None,\n    collection_sanitization_strategy: SanitizationStrategy | None = None,\n    auto_create: bool = True,\n) -&gt; None\n</code></pre> <pre><code>__init__(\n    *,\n    client=None,\n    url=None,\n    db_name=None,\n    coll_name=None,\n    default_collection=None,\n    collection_sanitization_strategy=None,\n    auto_create=True,\n)\n</code></pre> <p>Initialize the MongoDB store.</p> <p>Values are stored as native BSON dictionaries for better query support and performance.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>AsyncMongoClient[dict[str, Any]] | None</code> <p>The MongoDB client to use (mutually exclusive with url). If provided, the store will not manage the client's lifecycle (will not enter/exit its context manager or close it). The caller is responsible for managing the client's lifecycle.</p> <code>None</code> <code>url</code> <code>str | None</code> <p>The url of the MongoDB cluster (mutually exclusive with client).</p> <code>None</code> <code>db_name</code> <code>str | None</code> <p>The name of the MongoDB database.</p> <code>None</code> <code>coll_name</code> <code>str | None</code> <p>The name of the MongoDB collection.</p> <code>None</code> <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided.</p> <code>None</code> <code>collection_sanitization_strategy</code> <code>SanitizationStrategy | None</code> <p>The sanitization strategy to use for collections.</p> <code>None</code> <code>auto_create</code> <code>bool</code> <p>Whether to automatically create collections if they don't exist. Defaults to True. When False, raises ValueError if a collection doesn't exist.</p> <code>True</code>"},{"location":"api/stores/#valkey-store","title":"Valkey Store","text":"<p>Valkey-backed key-value store (Redis-compatible).</p>"},{"location":"api/stores/#key_value.aio.stores.valkey.ValkeyStore","title":"ValkeyStore","text":"<p>               Bases: <code>BaseContextManagerStore</code>, <code>BaseStore</code></p> <p>Valkey-based key-value store (Redis protocol compatible).</p> <p>Supports both standalone (GlideClient) and cluster (GlideClusterClient) deployments.</p>"},{"location":"api/stores/#key_value.aio.stores.valkey.ValkeyStore.__init__","title":"__init__","text":"<pre><code>__init__(*, client: GlideClient, default_collection: str | None = None) -&gt; None\n</code></pre><pre><code>__init__(\n    *, client: GlideClusterClient, default_collection: str | None = None\n) -&gt; None\n</code></pre><pre><code>__init__(\n    *,\n    host: str = \"localhost\",\n    port: int = 6379,\n    db: int = 0,\n    username: str | None = None,\n    password: str | None = None,\n    default_collection: str | None = None,\n) -&gt; None\n</code></pre> <pre><code>__init__(\n    *,\n    client=None,\n    default_collection=None,\n    host=\"localhost\",\n    port=6379,\n    db=0,\n    username=None,\n    password=None,\n)\n</code></pre> <p>Initialize the Valkey store.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>BaseClient | None</code> <p>An existing Valkey client to use (GlideClient or GlideClusterClient). If provided, the store will not manage the client's lifecycle (will not close it). The caller is responsible for managing the client's lifecycle.</p> <code>None</code> <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided.</p> <code>None</code> <code>host</code> <code>str</code> <p>Valkey host. Defaults to localhost.</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Valkey port. Defaults to 6379.</p> <code>6379</code> <code>db</code> <code>int</code> <p>Valkey database number. Defaults to 0.</p> <code>0</code> <code>username</code> <code>str | None</code> <p>Valkey username. Defaults to None.</p> <code>None</code> <code>password</code> <code>str | None</code> <p>Valkey password. Defaults to None.</p> <code>None</code> Note <p>When using a cluster client, the host/port/db parameters are ignored. You must provide a pre-configured GlideClusterClient instance.</p>"},{"location":"api/stores/#memcached-store","title":"Memcached Store","text":"<p>Memcached-backed key-value store.</p>"},{"location":"api/stores/#key_value.aio.stores.memcached.MemcachedStore","title":"MemcachedStore","text":"<p>               Bases: <code>BaseDestroyStore</code>, <code>BaseContextManagerStore</code>, <code>BaseStore</code></p> <p>Memcached-based key-value store using aiomcache.</p> <p>By default, keys are not sanitized. This means that there are character and length restrictions on keys that may cause errors when trying to get and put entries.</p> <p>To avoid issues, you may want to consider leveraging the <code>MemcachedV1KeySanitizationStrategy</code> strategy.</p>"},{"location":"api/stores/#key_value.aio.stores.memcached.MemcachedStore.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    client: Client,\n    default_collection: str | None = None,\n    key_sanitization_strategy: SanitizationStrategy | None = None,\n) -&gt; None\n</code></pre><pre><code>__init__(\n    *,\n    host: str = \"127.0.0.1\",\n    port: int = 11211,\n    default_collection: str | None = None,\n    key_sanitization_strategy: SanitizationStrategy | None = None,\n) -&gt; None\n</code></pre> <pre><code>__init__(\n    *,\n    client=None,\n    host=\"127.0.0.1\",\n    port=11211,\n    default_collection=None,\n    key_sanitization_strategy=None,\n)\n</code></pre> <p>Initialize the Memcached store.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client | None</code> <p>An existing aiomcache client to use. If provided, the store will not manage the client's lifecycle (will not close it). The caller is responsible for managing the client's lifecycle.</p> <code>None</code> <code>host</code> <code>str</code> <p>Memcached host. Defaults to 127.0.0.1.</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>Memcached port. Defaults to 11211.</p> <code>11211</code> <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided.</p> <code>None</code> <code>key_sanitization_strategy</code> <code>SanitizationStrategy | None</code> <p>The sanitization strategy to use for keys.</p> <code>None</code>"},{"location":"api/stores/#null-store","title":"Null Store","text":"<p>A no-op store that doesn't persist anything, useful for testing.</p>"},{"location":"api/stores/#key_value.aio.stores.null.NullStore","title":"NullStore","text":"<p>               Bases: <code>BaseStore</code></p> <p>Null object pattern store that accepts all operations but stores nothing.</p>"},{"location":"api/wrappers/","title":"Wrappers API Reference","text":"<p>Complete API reference for all available wrappers.</p>"},{"location":"api/wrappers/#base-wrapper","title":"Base Wrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.base.BaseWrapper","title":"BaseWrapper","text":"<p>               Bases: <code>AsyncKeyValue</code></p> <p>A base wrapper for KVStore implementations that passes through to the underlying store.</p> <p>This class implements the passthrough pattern where all operations are delegated to the wrapped key-value store without modification. It serves as a foundation for creating custom wrappers that need to intercept, modify, or enhance specific operations while passing through others unchanged.</p> <p>To create a custom wrapper, subclass this class and override only the methods you need to customize. All other operations will automatically pass through to the underlying store.</p> Example <p>class LoggingWrapper(BaseWrapper):     async def get(self, key: str, *, collection: str | None = None):         logger.info(f\"Getting key: {key}\")         return await super().get(key, collection=collection)</p> <p>Attributes:</p> Name Type Description <code>key_value</code> <code>AsyncKeyValue</code> <p>The underlying AsyncKeyValue store that operations are delegated to.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.base.BaseWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.base.BaseWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.base.BaseWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.base.BaseWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.base.BaseWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.base.BaseWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.base.BaseWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.base.BaseWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.base.BaseWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#compressionwrapper","title":"CompressionWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.compression.CompressionWrapper","title":"CompressionWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that compresses values before storing and decompresses on retrieval.</p> <p>This wrapper compresses the JSON-serialized value using the specified compression algorithm and stores it as a base64-encoded string within a special key in the dictionary. This allows compression while maintaining the dict[str, Any] interface.</p> <p>The compressed format looks like: {     \"compressed_data\": \"base64-encoded-compressed-data\",     \"compression_algorithm\": \"gzip\",     \"compression_version\": 1 }</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.min_size_to_compress","title":"min_size_to_compress  <code>instance-attribute</code>","text":"<pre><code>min_size_to_compress = min_size_to_compress\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, min_size_to_compress=1024)\n</code></pre> <p>Initialize the compression wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>min_size_to_compress</code> <code>int</code> <p>Only compress values larger than this many bytes.                  Defaults to 1024 bytes (1KB).</p> <code>1024</code>"},{"location":"api/wrappers/#key_value.aio.wrappers.compression.CompressionWrapper._compress_value","title":"_compress_value","text":"<pre><code>_compress_value(value)\n</code></pre> <p>Compress a value into the compressed format.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.compression.CompressionWrapper._decompress_value","title":"_decompress_value","text":"<pre><code>_decompress_value(value)\n</code></pre> <p>Decompress a value from the compressed format.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.compression.CompressionWrapper._should_compress","title":"_should_compress","text":"<pre><code>_should_compress(value)\n</code></pre> <p>Determine if a value should be compressed based on its size.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.compression.CompressionWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#fernetencryptionwrapper","title":"FernetEncryptionWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.encryption.fernet.FernetEncryptionWrapper","title":"FernetEncryptionWrapper","text":"<p>               Bases: <code>BaseEncryptionWrapper</code></p> <p>Wrapper that encrypts values before storing and decrypts on retrieval using Fernet (symmetric encryption).</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.encryption.fernet.FernetEncryptionWrapper.__init__","title":"__init__","text":"<pre><code>__init__(\n    key_value: AsyncKeyValue,\n    *,\n    fernet: Fernet | MultiFernet,\n    raise_on_decryption_error: bool = True,\n) -&gt; None\n</code></pre><pre><code>__init__(\n    key_value: AsyncKeyValue,\n    *,\n    source_material: str,\n    salt: str,\n    raise_on_decryption_error: bool = True,\n) -&gt; None\n</code></pre> <pre><code>__init__(\n    key_value,\n    *,\n    fernet=None,\n    source_material=None,\n    salt=None,\n    raise_on_decryption_error=True,\n)\n</code></pre>"},{"location":"api/wrappers/#fallbackwrapper","title":"FallbackWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper","title":"FallbackWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that falls back to a secondary store when the primary store fails.</p> <p>This wrapper attempts operations on the primary store first. If the operation fails with one of the specified exceptions, it automatically falls back to the secondary store. This provides high availability and graceful degradation when the primary store is unavailable.</p> <p>Note: This wrapper only provides read fallback by default. Writes always go to the primary store. For write fallback, consider using write_to_fallback=True, but be aware of potential consistency issues.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.fallback_key_value","title":"fallback_key_value  <code>instance-attribute</code>","text":"<pre><code>fallback_key_value = fallback_key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.fallback_on","title":"fallback_on  <code>instance-attribute</code>","text":"<pre><code>fallback_on = fallback_on\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.primary_key_value","title":"primary_key_value  <code>instance-attribute</code>","text":"<pre><code>primary_key_value = primary_key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.write_to_fallback","title":"write_to_fallback  <code>instance-attribute</code>","text":"<pre><code>write_to_fallback = write_to_fallback\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.__init__","title":"__init__","text":"<pre><code>__init__(\n    primary_key_value,\n    fallback_key_value,\n    fallback_on=(Exception,),\n    write_to_fallback=False,\n)\n</code></pre> <p>Initialize the fallback wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>primary_key_value</code> <code>AsyncKeyValue</code> <p>The primary store to use.</p> required <code>fallback_key_value</code> <code>AsyncKeyValue</code> <p>The fallback store to use when primary fails.</p> required <code>fallback_on</code> <code>tuple[type[Exception], ...]</code> <p>Tuple of exception types that trigger fallback. Defaults to (Exception,).</p> <code>(Exception,)</code> <code>write_to_fallback</code> <code>bool</code> <p>If True, write operations also fall back to secondary store.                If False (default), write operations only go to primary.</p> <code>False</code>"},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.fallback.FallbackWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#limitsizewrapper","title":"LimitSizeWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper","title":"LimitSizeWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that limits the size of entries stored in the cache. When using a key_value store as a cache, you may want to prevent caching of very small or very large entries. This wrapper allows you to silently (or loudly) ignore entries that do not fall within the specified size limits.</p> <p>This wrapper checks the serialized size of values before storing them. This incurs a performance penalty as it requires JSON serialization of the value separate from serialization that occurs when the value is stored.</p> <p>This wrapper does not prevent returning objects (get, ttl, get_many, ttl_many) that exceed the size limit, just storing them (put, put_many).</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.max_size","title":"max_size  <code>instance-attribute</code>","text":"<pre><code>max_size = max_size\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.min_size","title":"min_size  <code>instance-attribute</code>","text":"<pre><code>min_size = min_size\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.raise_on_too_large","title":"raise_on_too_large  <code>instance-attribute</code>","text":"<pre><code>raise_on_too_large = raise_on_too_large\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.raise_on_too_small","title":"raise_on_too_small  <code>instance-attribute</code>","text":"<pre><code>raise_on_too_small = raise_on_too_small\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.__init__","title":"__init__","text":"<pre><code>__init__(\n    key_value,\n    *,\n    min_size=None,\n    max_size=None,\n    raise_on_too_small=False,\n    raise_on_too_large=True,\n)\n</code></pre> <p>Initialize the limit size wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>min_size</code> <code>int | None</code> <p>The minimum size (in bytes) allowed for each entry. If None, no minimum size is enforced.</p> <code>None</code> <code>max_size</code> <code>int | None</code> <p>The maximum size (in bytes) allowed for each entry. If None, no maximum size is enforced.</p> <code>None</code> <code>raise_on_too_small</code> <code>bool</code> <p>If True, raises EntryTooSmallError when an entry is less than min_size.                  If False (default), silently ignores entries that are too small.</p> <code>False</code> <code>raise_on_too_large</code> <code>bool</code> <p>If True (default), raises EntryTooLargeError when an entry exceeds max_size.                  If False, silently ignores entries that are too large.</p> <code>True</code>"},{"location":"api/wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper._within_size_limit","title":"_within_size_limit","text":"<pre><code>_within_size_limit(value, *, collection=None, key=None)\n</code></pre> <p>Check if a value exceeds the maximum size.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict[str, Any]</code> <p>The value to check.</p> required <code>collection</code> <code>str | None</code> <p>The collection name (for error messages).</p> <code>None</code> <code>key</code> <code>str | None</code> <p>The key name (for error messages).</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the value is within the size limit, False otherwise.</p> <p>Raises:</p> Type Description <code>EntryTooSmallError</code> <p>If raise_on_too_small is True and the value is less than min_size.</p> <code>EntryTooLargeError</code> <p>If raise_on_too_large is True and the value exceeds max_size.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.limit_size.LimitSizeWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#loggingwrapper","title":"LoggingWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper","title":"LoggingWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that logs all operations for debugging and auditing.</p> <p>This wrapper logs all key-value operations including their parameters and results. It's useful for: - Debugging application behavior - Auditing data access - Understanding cache hit/miss patterns - Monitoring performance issues</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.log_level","title":"log_level  <code>instance-attribute</code>","text":"<pre><code>log_level = log_level\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.log_values","title":"log_values  <code>instance-attribute</code>","text":"<pre><code>log_values = log_values\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger or getLogger('key_value.logging')\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.structured_logs","title":"structured_logs  <code>instance-attribute</code>","text":"<pre><code>structured_logs = structured_logs\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.__init__","title":"__init__","text":"<pre><code>__init__(\n    key_value,\n    logger=None,\n    log_level=INFO,\n    log_values=False,\n    structured_logs=False,\n)\n</code></pre> <p>Initialize the logging wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>logger</code> <code>Logger | None</code> <p>Logger instance to use. If None, creates a logger named 'key_value.logging'.</p> <code>None</code> <code>log_level</code> <code>int</code> <p>Logging level to use. Defaults to logging.INFO.</p> <code>INFO</code> <code>log_values</code> <code>bool</code> <p>If True, logs the actual values being stored/retrieved.        If False (default), only logs metadata (keys, collections, operation types).        Set to False to avoid logging sensitive data.</p> <code>False</code> <code>structured_logs</code> <code>bool</code> <p>If True, logs the values as structured data.        If False (default), logs the values as a string.</p> <code>False</code>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper._format_collection","title":"_format_collection","text":"<pre><code>_format_collection(collection)\n</code></pre> <p>Format collection name for logging.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper._format_message","title":"_format_message","text":"<pre><code>_format_message(state, action, keys, collection, values=None, extra=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper._log","title":"_log","text":"<pre><code>_log(state, action, keys, collection, values=None, extra=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.logging.LoggingWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#passthroughcachewrapper","title":"PassthroughCacheWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper","title":"PassthroughCacheWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Two-tier wrapper: reads from cache store, falls back to primary and populates cache.</p> <p>TTLs from the primary are respected when writing into the cache using a clamped TTL policy.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.cache_key_value","title":"cache_key_value  <code>instance-attribute</code>","text":"<pre><code>cache_key_value = TTLClampWrapper(\n    key_value=cache_key_value,\n    min_ttl=0,\n    max_ttl=maximum_ttl or DEFAULT_MAX_TTL,\n    missing_ttl=missing_ttl or DEFAULT_MISSING_TTL,\n)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.primary_key_value","title":"primary_key_value  <code>instance-attribute</code>","text":"<pre><code>primary_key_value = primary_key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.unwrapped_cache_key_value","title":"unwrapped_cache_key_value  <code>instance-attribute</code>","text":"<pre><code>unwrapped_cache_key_value = cache_key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.__init__","title":"__init__","text":"<pre><code>__init__(\n    primary_key_value, cache_key_value, maximum_ttl=None, missing_ttl=None\n)\n</code></pre> <p>Initialize the passthrough cache wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>primary_key_value</code> <code>AsyncKeyValue</code> <p>The primary store to wrap.</p> required <code>cache_key_value</code> <code>AsyncKeyValue</code> <p>The cache store to wrap.</p> required <code>maximum_ttl</code> <code>SupportsFloat | None</code> <p>The maximum TTL for puts into the cache store. Defaults to 30 minutes.</p> <code>None</code> <code>missing_ttl</code> <code>SupportsFloat | None</code> <p>The TTL to use for entries that do not have a TTL. Defaults to 30 minutes.</p> <code>None</code>"},{"location":"api/wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.passthrough_cache.PassthroughCacheWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#prefixcollectionswrapper","title":"PrefixCollectionsWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper","title":"PrefixCollectionsWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>A wrapper that prefixes collection names before delegating to the underlying store.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.default_collection","title":"default_collection  <code>instance-attribute</code>","text":"<pre><code>default_collection = default_collection or DEFAULT_COLLECTION_NAME\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.prefix","title":"prefix  <code>instance-attribute</code>","text":"<pre><code>prefix = prefix\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, prefix, default_collection=None)\n</code></pre> <p>Initialize the prefix collections wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>prefix</code> <code>str</code> <p>The prefix to add to the collections.</p> required <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided. Will be automatically prefixed with the <code>prefix</code></p> <code>None</code>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper._prefix_collection","title":"_prefix_collection","text":"<pre><code>_prefix_collection(collection)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper._unprefix_collection","title":"_unprefix_collection","text":"<pre><code>_unprefix_collection(collection)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_collections.PrefixCollectionsWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#prefixkeyswrapper","title":"PrefixKeysWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper","title":"PrefixKeysWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>A wrapper that prefixes key names before delegating to the underlying store.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.prefix","title":"prefix  <code>instance-attribute</code>","text":"<pre><code>prefix = prefix\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, prefix)\n</code></pre> <p>Initialize the prefix keys wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>prefix</code> <code>str</code> <p>The prefix to add to the keys.</p> required"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper._prefix_key","title":"_prefix_key","text":"<pre><code>_prefix_key(key)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper._unprefix_key","title":"_unprefix_key","text":"<pre><code>_unprefix_key(key)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.prefix_keys.PrefixKeysWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#readonlywrapper","title":"ReadOnlyWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper","title":"ReadOnlyWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that prevents all write operations on the underlying store.</p> <p>This wrapper allows all read operations (get, get_many, ttl, ttl_many) to pass through normally, but blocks all write operations (put, put_many, delete, delete_many). This is useful for: - Protecting production data during testing - Enforcing read-only access to read replicas - Preventing accidental modifications in certain environments</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.raise_on_write","title":"raise_on_write  <code>instance-attribute</code>","text":"<pre><code>raise_on_write = raise_on_write\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, raise_on_write=True)\n</code></pre> <p>Initialize the read-only wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>raise_on_write</code> <code>bool</code> <p>If True (default), raises ReadOnlyError on write attempts.            If False, silently ignores writes (put/put_many return None,            delete/delete_many return False/0).</p> <code>True</code>"},{"location":"api/wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.read_only.ReadOnlyWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#retrywrapper","title":"RetryWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper","title":"RetryWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that retries failed operations with exponential backoff.</p> <p>This wrapper automatically retries operations that fail with specified exceptions, using exponential backoff between attempts. This is useful for handling transient failures like network issues or temporary service unavailability.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.exponential_base","title":"exponential_base  <code>instance-attribute</code>","text":"<pre><code>exponential_base = exponential_base\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.initial_delay","title":"initial_delay  <code>instance-attribute</code>","text":"<pre><code>initial_delay = initial_delay\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.max_delay","title":"max_delay  <code>instance-attribute</code>","text":"<pre><code>max_delay = max_delay\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.max_retries","title":"max_retries  <code>instance-attribute</code>","text":"<pre><code>max_retries = max_retries\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.retry_on","title":"retry_on  <code>instance-attribute</code>","text":"<pre><code>retry_on = retry_on\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.__init__","title":"__init__","text":"<pre><code>__init__(\n    key_value,\n    max_retries=3,\n    initial_delay=0.1,\n    max_delay=10.0,\n    exponential_base=2.0,\n    retry_on=(ConnectionError, TimeoutError),\n)\n</code></pre> <p>Initialize the retry wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>max_retries</code> <code>int</code> <p>Maximum number of retry attempts. Defaults to 3.</p> <code>3</code> <code>initial_delay</code> <code>float</code> <p>Initial delay in seconds before first retry. Defaults to 0.1.</p> <code>0.1</code> <code>max_delay</code> <code>float</code> <p>Maximum delay in seconds between retries. Defaults to 10.0.</p> <code>10.0</code> <code>exponential_base</code> <code>float</code> <p>Base for exponential backoff calculation. Defaults to 2.0.</p> <code>2.0</code> <code>retry_on</code> <code>tuple[type[Exception], ...]</code> <p>Tuple of exception types to retry on. Defaults to (ConnectionError, TimeoutError).</p> <code>(ConnectionError, TimeoutError)</code>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper._calculate_delay","title":"_calculate_delay","text":"<pre><code>_calculate_delay(attempt)\n</code></pre> <p>Calculate the delay for a given attempt using exponential backoff.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.retry.RetryWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#singlecollectionwrapper","title":"SingleCollectionWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper","title":"SingleCollectionWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>A wrapper that stores all collections within a single backing collection via key prefixing.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.default_collection","title":"default_collection  <code>instance-attribute</code>","text":"<pre><code>default_collection = default_collection or DEFAULT_COLLECTION_NAME\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.separator","title":"separator  <code>instance-attribute</code>","text":"<pre><code>separator = separator or DEFAULT_PREFIX_SEPARATOR\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.single_collection","title":"single_collection  <code>instance-attribute</code>","text":"<pre><code>single_collection = single_collection\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, single_collection, default_collection=None, separator=None)\n</code></pre> <p>Initialize the prefix collections wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>single_collection</code> <code>str</code> <p>The single collection to use to store all collections.</p> required <code>default_collection</code> <code>str | None</code> <p>The default collection to use if no collection is provided.</p> <code>None</code> <code>separator</code> <code>str | None</code> <p>The separator to use for the key prefix.</p> <code>None</code>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper._prefix_key","title":"_prefix_key","text":"<pre><code>_prefix_key(key, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper._unprefix_key","title":"_unprefix_key","text":"<pre><code>_unprefix_key(key)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.single_collection.SingleCollectionWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#ttlclampwrapper","title":"TTLClampWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper","title":"TTLClampWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that enforces a maximum TTL for puts into the store.</p> <p>This wrapper only modifies write operations (put, put_many). All read operations (get, get_many, ttl, ttl_many, delete, delete_many) pass through unchanged to the underlying store.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.max_ttl","title":"max_ttl  <code>instance-attribute</code>","text":"<pre><code>max_ttl = float(max_ttl)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.min_ttl","title":"min_ttl  <code>instance-attribute</code>","text":"<pre><code>min_ttl = float(min_ttl)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.missing_ttl","title":"missing_ttl  <code>instance-attribute</code>","text":"<pre><code>missing_ttl = float(missing_ttl) if missing_ttl is not None else None\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, min_ttl, max_ttl, missing_ttl=None)\n</code></pre> <p>Initialize the TTL clamp wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>min_ttl</code> <code>SupportsFloat</code> <p>The minimum TTL for puts into the store.</p> required <code>max_ttl</code> <code>SupportsFloat</code> <p>The maximum TTL for puts into the store.</p> required <code>missing_ttl</code> <code>SupportsFloat | None</code> <p>The TTL to use for entries that do not have a TTL. Defaults to None.</p> <code>None</code>"},{"location":"api/wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper._ttl_clamp","title":"_ttl_clamp","text":"<pre><code>_ttl_clamp(ttl: SupportsFloat) -&gt; float\n</code></pre><pre><code>_ttl_clamp(ttl: SupportsFloat | None) -&gt; float | None\n</code></pre> <pre><code>_ttl_clamp(ttl)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.ttl_clamp.TTLClampWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#statisticswrapper","title":"StatisticsWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper","title":"StatisticsWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Statistics wrapper around a KV Store that tracks operation statistics.</p> <p>Note: enumeration and destroy operations are not tracked by this wrapper.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper._statistics","title":"_statistics  <code>instance-attribute</code>","text":"<pre><code>_statistics = KVStoreStatistics()\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.statistics","title":"statistics  <code>property</code>","text":"<pre><code>statistics\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.statistics.StatisticsWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#timeoutwrapper","title":"TimeoutWrapper","text":""},{"location":"api/wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper","title":"TimeoutWrapper","text":"<p>               Bases: <code>BaseWrapper</code></p> <p>Wrapper that adds timeout limits to all operations.</p> <p>This wrapper ensures that no operation takes longer than the specified timeout. If an operation exceeds the timeout, it raises asyncio.TimeoutError. This is useful for preventing operations from hanging indefinitely and for enforcing SLAs.</p>"},{"location":"api/wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.key_value","title":"key_value  <code>instance-attribute</code>","text":"<pre><code>key_value = key_value\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout = timeout\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.__init__","title":"__init__","text":"<pre><code>__init__(key_value, timeout=5.0)\n</code></pre> <p>Initialize the timeout wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>key_value</code> <code>AsyncKeyValue</code> <p>The store to wrap.</p> required <code>timeout</code> <code>float</code> <p>Timeout in seconds for all operations. Defaults to 5.0 seconds.</p> <code>5.0</code>"},{"location":"api/wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.get","title":"get  <code>async</code>","text":"<pre><code>get(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.put","title":"put  <code>async</code>","text":"<pre><code>put(key, value, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.put_many","title":"put_many  <code>async</code>","text":"<pre><code>put_many(keys, values, *, collection=None, ttl=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.ttl","title":"ttl  <code>async</code>","text":"<pre><code>ttl(key, *, collection=None)\n</code></pre>"},{"location":"api/wrappers/#key_value.aio.wrappers.timeout.TimeoutWrapper.ttl_many","title":"ttl_many  <code>async</code>","text":"<pre><code>ttl_many(keys, *, collection=None)\n</code></pre>"}]}